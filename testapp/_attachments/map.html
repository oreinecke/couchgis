<!DOCTYPE html>

<html lang="de" style="height:90%">
  <head>
    <title>Karte</title>
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8">

    <script src="script/jquery-1.10.2.js"></script>
    <script src="script/jquery.couch.js"></script>
    <script src="script/login_bar.js"></script>
    <script type="text/javascript" src="https://maps.googleapis.com/maps/api/js?v=3.exp&sensor=false"></script>

<script type="text/javascript">
$(document).ready(function() {
  // let's try with only one document for now!!!
  var doc_id="c76eef44f37d9af942135711a602ae3c";
  var parts=window.location.pathname.match(/[^/]+/g);
  var db=$.couch.db(parts[0]);
  var app=parts[2];

  // stash frequently used objects here
  var Maps=google.maps;
  var LatLng=Maps.LatLng;
  var LatLngBounds=Maps.LatLngBounds;

  var map = new Maps.Map(document.getElementById('map'), {
    zoom: 14,
    mapTypeId: Maps.MapTypeId.SATELLITE,
    center: new LatLng(50.84821949128975, 13.798296875)
  });

  MAP=map; // remove me!! I am just for the FF js shell

  var list=function() {
    var parts=window.location.pathname.match(/[^/]+/g);
    var db=$.couch.db(parts[0]);
    var app=parts[2];
    return function(view, data, options) {
      return db.list(app+"/bbox-filter", view, data, options);
    }
  }();

  // It is very likely that the oftentimes inexperienced user clicks and
  // scrolls the map like an ape (on adderall). Then, event handler callbacks
  // will be fired all over the place and the interface probably won't react
  // anymore. It should be smarter than that; It should wait a couple of
  // seconds, then wait for the last ajax to complete, then do the next thing
  // that needs to be done. 
  var call={
    now:null, next:null,
    this_one_next:function(what) {
      if (this.now!==null) this.next=what;
      else (this.now=what)();
    },
    that_last_one:function() {
      this.now=this.next;
      this.next=null;
      if (this.now!==null) this.now();
    }
  };
  // All items that are displayed on the map are in here as "id":{etc.}.
  var items={};
  // This contains a partially ordered list of GeoJSON ids for list().
  var keys=[];

  // check if accuracy is justified and replace GeoJSON if not
  function update_geometry(error) {
    if (error==null) {
      var NE=map.getBounds().getNorthEast();
      var SW=map.getBounds().getSouthWest();
      // estimate error from screen height
      error=(NE.lat()-SW.lat())/100;
    }
    var keys=[];
    for (var id in items) {
      var last_error=items[id].GeoJSON.error;
      if (last_error==null||error>2*last_error||last_error>2*error)
        keys.push(id);
    }
    if (!keys.length) {
      call.that_last_one();
      return;
    }
    list("geojson", {keys:keys, error:error}, {success:function(data) {
      for (var id in data) {
        var GeoJSON=data[id].GeoJSON;
        if (items[id].GeoJSON.error===GeoJSON.error) continue;
        var paths=[];
        // remind myself that this needs work!!!
        if (GeoJSON.type!="Polygon") { alert("OH NO POKEY AN UNKNOWN GEOJSON TYPE!!!"); return; }
        for (var path=0;path<GeoJSON.coordinates.length;path++) {
          paths.push([]);
          var coords=GeoJSON.coordinates[path];
          for (var coord=0;coord<coords.length;coord++) {
            paths[path].push(new LatLng(coords[coord][1], coords[coord][0]));
          }
        }
        var shape=new Maps.Polygon({ paths:paths, fillOpacity: 0 });
        shape.setMap(map);
        if (items[id].shape)
          items[id].shape.setMap();
        // there is no need to keep all the polygons
        items[id]={
          GeoJSON: { error: data[id].GeoJSON.error },
          docs: data[id].docs, shape: shape
        }
      }
      call.that_last_one();
    }});
  }

  // The key initialization should probably happen here: we just need a query
  // that yields an ordered id list and a bbox as union of all bboxes or at
  // least a center to point the map to.
  list("bbox-size", {}, {success:function(data) {
    var bbox=data[doc_id].GeoJSON.bbox;
    map.setCenter(new LatLng((bbox[3]+bbox[1])/2,(bbox[2]+bbox[0])/2));
    var keys=[];
    for (var id in data) {
      items[id]=data[id];
      keys.push(id);
    }
    update_geometry(10e-5);
  }});

  // update GeoJSON according to viewport here.
  Maps.event.addListener(map, 'zoom_changed', function() {call.this_one_next(update_geometry);} );
//Maps.event.addListener(map, 'zoom_changed', update_geometry );

});
</script>

  </head>
  <body style="height:90%">

  <iframe src="login_bar.htm" style="width:100%; height:1.4em; border:0;"></iframe>

  <h1> Karte </h1>
  <div id="map" style="height:90%"></div>

  </body>
</html>
