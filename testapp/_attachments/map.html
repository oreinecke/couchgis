<!DOCTYPE html>

<html lang="de" style="height:90%">
  <head>
    <title>Karte</title>
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8">

    <script src="script/jquery-1.10.2.js"></script>
    <script type="text/javascript" src="https://maps.googleapis.com/maps/api/js?v=3.exp&sensor=false"></script>

<script type="text/javascript">
$(document).ready(function() {

  // stash frequently used objects here
  var Maps=google.maps;
  var LatLng=Maps.LatLng;
  var LatLngBounds=Maps.LatLngBounds;

  var map = new Maps.Map($('#map')[0], {
    zoom: 12,
    mapTypeId: Maps.MapTypeId.SATELLITE,
    center: new LatLng(50.83730534254573, 13.938310197234163)
  });

  // call _list/bbox-filter/<view> with some useful options
  function list(view, data, success) {
    $.ajax("_list/bbox-filter/"+view, {
      type:"POST",
      data:JSON.stringify(data),
      success:success,
      error:call.that_last_one
    });
  }
  // ok this also looks retarded but it keeps my stuff in one place at least
  list.parts=window.location.pathname.match(/[^/]+/g);
  list.db=list.parts[0];
  list.app=list.parts[2];

  // It is very likely that the oftentimes inexperienced user clicks and
  // scrolls the map like an ape (on adderall). Then, event handler callbacks
  // will be fired all over the place and the interface probably won't react
  // anymore. It should be smarter than that; It should wait a couple of
  // seconds, then wait for the last ajax to complete, then do the next thing
  // that needs to be done. 
  var call={
    now:null, next:null,
    this_one_next:function(what) {
      // We might as well do the closure here, because this
      // is used only for event handler registration anyway.
      return function() {
        if (call.now!==null) call.next=what;
        else (call.now=what)();
      }
    },
    that_last_one:function() {
      window.setTimeout(function() {
        call.now=call.next;
        call.next=null;
        if (call.now!==null) call.now();
      }, 500);
    },
    no_one:function() {
      call.now=null;
      call.next=null;
    }
  };
  // All items that are displayed on the map are in here as "id":{etc.}.
  var items={};
  // This contains an ordered list of ALL GeoJSON keys.
  var keys=[];
  // This contains a descending viewport array,
  // initialized to one default element.
  var viewports=[{
    bbox: [-Infinity,-Infinity,Infinity,Infinity],
    prefix: [], // (limited) items returned by this viewport
    position: 0 // index from which to append remaining keys
  }];

  // check if accuracy is justified and replace GeoJSON if not
  function update_geometry(error) {
    var keys=[];
    for (var id in items)
      if (!items[id].keep || error<items[id].GeoJSON.error)
        keys.push(id);
    if (!keys.length) {
      call.that_last_one();
      return;
    }
    // timeout is 50ms or instantaneous
    var timeout = 50 * $("#settings [name='delayed']").prop('checked');
    list("geojson", {keys:keys, error:error}, function(data) {
      function update_one_geometry() {
        for (var id in data) {
          var item=data[id];
          var GeoJSON=item.GeoJSON;
          delete data[id];
          var paths=[];
          // remind myself that this needs work!!!
          if (GeoJSON.type!="Polygon") { alert("OH NO POKEY AN UNKNOWN GEOJSON TYPE!!!"); return; }
          for (var path=0;path<GeoJSON.coordinates.length;path++) {
            paths.push([]);
            var coords=GeoJSON.coordinates[path];
            for (var coord=0;coord<coords.length-1;coord++)
              paths[path].push(new LatLng(coords[coord][1], coords[coord][0]));
          }
          var shape=new Maps.Polygon({ paths:paths, fillOpacity: 0.25, fillColor: '#00FF80' });
          shape.setMap(map);
          // select link if user clicks on shape
          Maps.event.addListener(shape, 'click', function(href) {
            return function() {href.focus();};
          }(items[id].link.find('a').last()));
          if (items[id].shape) items[id].shape.setMap();
          // there is no need to keep all the polygons
          items[id].GeoJSON={error:GeoJSON.error};
          items[id].docs=item.docs;
          items[id].shape=shape;
          if (!timeout) continue
          window.setTimeout(update_one_geometry, timeout);
          return;
        }
        call.that_last_one();
      }
      update_one_geometry();
    });
  }

  // diff-updates items inside viewport
  function update_items(error) {
    var NE=map.getBounds().getNorthEast();
    var SW=map.getBounds().getSouthWest();
    var options={
      limit:parseFloat($("#settings [name='limit']").val()),
      error:error==null?(NE.lat()-SW.lat())/100:error,
      unsorted:0,
      bbox:[SW.lng(),SW.lat(),NE.lng(),NE.lat()]
    };
    var vp;
    // remove viewports until 
    do vp=viewports.pop();
    while (options.bbox[0]<vp.bbox[0]||options.bbox[1]<vp.bbox[1]||
           options.bbox[2]>vp.bbox[2]||options.bbox[3]>vp.bbox[3]);
    // the last viewport is valid, so it needs to be re-stacked
    viewports.push(vp);
    // ignore items that were already dropped by previous viewport
    options.keys=vp.prefix.join(keys.slice(vp.position)),
    var details = $("#details")
    list("bbox-size", options, function(data) {
      // lists items to be removed as {id:null}
      var old_items={};
      for (var id in items) old_items[id]=null;
      // prepare new viewport
      var vp={ bbox:options.bbox, prefix:[] };
      // I need the last prop of data after the loop again. This is one
      // exceptional case where no 'var' is found in a for-statement.
      var id; for (id in data) {
        if (items[id]==null) items[id]=data[id];
        else items[id].keep=(items[id].GeoJSON.error===data[id].GeoJSON.error)
        delete old_items[id];
        if (items[id].link==null) {
          var link=$(document.createElement("li"));
          for (doc=0;doc<items[id].docs.length;doc++) {
            // Group docs with identical GIS into one li.
            if (doc) link.append("<br>");
            // Link to Futon for the lack of a better interface.
            link.append('<a href="/_utils/document.html?'+list.db+'/'
                         +items[id].docs[doc]._id+'">'+items[id].docs[doc]._id+'</a>');
          }
          details.append(link);
          items[id].link=link;
        }
        vp.prefix.push(id);
      }
      vp.position=keys.indexOf(id)+1;
      viewports.push(vp);
      for (var id in old_items) {
        // shape is not guaranteed to be set because
        // _list/bbox-filter/geojson might be unsuccessful
        if (items[id].shape) items[id].shape.setMap();
        items[id].link.remove();
        delete items[id];
      }
      // Put a small delay between both lists to
      // let CouchDB recover from its previous crash.
      window.setTimeout(function() {update_geometry(options.error);}, 10);
    });
  }

  // initialize map position and geometry as soon as map has finished loading.
  Maps.event.addListenerOnce(map, 'tilesloaded', function() {
    // set viewport and zoom level
    $.getJSON("_view/dimensions", function(data) {
      var bbox=data.rows[0].value.bbox;
      map.setCenter(new LatLng((bbox[3]+bbox[1])/2.0, (bbox[2]+bbox[0])/2.0));
      //map.panToBounds(new LatLngBounds(new LatLng(bbox[1],bbox[0]),new LatLng(bbox[3],bbox[2])));
    });
    // get list of GeoJSON keys, largest to smallest item
    $.getJSON("_view/dimensions?reduce=false&descending=true", function(data) {
      for (var row=0;row<data.rows.length;row++)
        keys.push(data.rows[row].id);
      update_items();
      // update GeoJSON according to viewport
      Maps.event.addListener(map, 'bounds_changed', call.this_one_next(update_items));
    });
    // cycle through geometric detail mode:
    // 'refine' <-> 'precise' -> 'simplified' -> 'refine'
    $("#settings [name='refine']").click( function() {
      $("#settings [name='refine']").hide();
      $("#settings [name='precise']").show();
      // show refined geometry once, and
      call.this_one_next(function() {update_geometry(0);})();
      // revert to 'refine', if viewport was moved
      Maps.event.addListenerOnce(map, 'bounds_changed', function() {
        $("#settings [name='precise']").hide();
        $("#settings [name='refine']").show();
      });
    });
    $("#settings [name='precise']").click( function() {
      $("#settings [name='precise']").hide();
      $("#settings [name='simplified']").show();
      Maps.event.clearListeners(map, 'bounds_changed');
      Maps.event.addListener(map, 'bounds_changed', call.this_one_next(function() {update_items(0);}));
    });
    $("#settings [name='simplified']").click( function() {
      $("#settings [name='simplified']").hide();
      $("#settings [name='refine']").show();
      Maps.event.clearListeners(map, 'bounds_changed');
      Maps.event.addListener(map, 'bounds_changed', call.this_one_next(update_items));
      Maps.event.trigger(map, 'bounds_changed');
    });
    // increase limit to next higher [1,2,5,10,20,50,etc]
    $("#settings [name='more']").click( function() {
      var limit=parseFloat($("#settings [name='limit']").val());
      var new_limit=10;
      while (new_limit<=limit) new_limit*=10;
      if (new_limit>5*limit) new_limit/=5;
      if (new_limit>2*limit) new_limit/=2;
      $("#settings [name='limit']").val(new_limit);
      Maps.event.trigger(map, 'bounds_changed');
    });
    // decrease limit to next lower [1,2,5,10,20,50,etc]
    $("#settings [name='less']").click( function() {
      var limit=parseFloat($("#settings [name='limit']").val());
      var new_limit=1;
      while (new_limit*10<limit) new_limit*=10;
      if (new_limit*5<limit) new_limit*=5;
      if (new_limit*2<limit) new_limit*=2;
      $("#settings [name='limit']").val(new_limit);
      Maps.event.trigger(map, 'bounds_changed');
    });
  });

});
</script>

<style>
  #details a:focus {font-weight:bold}
  #settings .geometry-level {width:6em}
</style>

  </head>
  <body style="height:90%">

  <iframe src="login_bar.htm" style="width:100%; height:1.6em; border:0;"></iframe>

  <h1> Karte </h1>
  <form id="settings">
    Darstellung:
    <input type="button" name="refine" class="geometry-level" value="verfeinern">
    <input type="button" name="precise" class="geometry-level" value="exakt" style="display:none">
    <input type="button" name="simplified" class="geometry-level" value="vereinfacht" style="display:none">
    <input type="checkbox" name="delayed">verzögert
    <input type="text" name="limit" size=2 value="50"> Polygone
    <input type="button" value="weniger" name="less">
    <input type="button" value="mehr" name="more">
  </form>
  <div id="map" style="height:90%"></div>
  <ul id="details"></ul>
  </body>
</html>
