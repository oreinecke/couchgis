<!DOCTYPE html>

<html lang="de" style="height:90%">
  <head>
    <title>Karte</title>
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8">

    <script src="script/jquery-1.10.2.js"></script>
    <script type="text/javascript" src="https://maps.googleapis.com/maps/api/js?v=3.exp&sensor=false"></script>

<script type="text/javascript">
$(document).ready(function() {

  // stash frequently used objects here
  var Maps=google.maps;
  var LatLng=Maps.LatLng;
  var LatLngBounds=Maps.LatLngBounds;

  var map = new Maps.Map($('#map')[0], {
    zoom: 12,
    mapTypeId: Maps.MapTypeId.SATELLITE,
    center: new LatLng(50.83730534254573, 13.938310197234163)
  });

  // some nice colors for different types
  var fillColors=['#00FF80','#8000FF','#80FF00','#FF8000','#0080FF'];

  // call _list/bbox-filter/<view> with some useful options
  function list(view, options, success) {
    var keys=(options.keys?'{"keys":["'+options.keys.join('","')+'"]}':"{}");
    options.keys=undefined;
    options.offset=list.offset;
    view+="?options="+encodeURIComponent(JSON.stringify(options));
    $.ajax("_list/bbox-filter/"+view, {
      type:"POST",
      data:keys,
      success:success,
      error:call.that_last_one
    });
  }
  // ok this also looks retarded but it keeps my stuff in one place at least
  list.parts=window.location.pathname.match(/[^/]+/g);
  list.db=list.parts[0];
  list.app=list.parts[2];
  // correct for small shift in Google Maps aerials of unknown reason
  list.offset=[-0.00178,-0.00121];

  // It is very likely that the oftentimes inexperienced user clicks and
  // scrolls the map like an ape (on adderall). Then, event handler callbacks
  // will be fired all over the place and the interface probably won't react
  // anymore. It should be smarter than that; It should wait a couple of
  // seconds, then wait for the last ajax to complete, then do the next thing
  // that needs to be done. 
  var call={
    now:null, next:null,
    this_one_next:function(what) {
      // We might as well do the closure here, because this
      // is used only for event handler registration anyway.
      return function() {
        if (call.now!==null) call.next=what;
        else (call.now=what)();
      }
    },
    that_last_one:function() {
      window.setTimeout(function() {
        call.now=call.next;
        call.next=null;
        if (call.now!==null) call.now();
      }, 500);
    },
    no_one:function() {
      call.now=null;
      call.next=null;
    }
  };
  // All items that are displayed on the map are in here as "id":{etc.}.
  var items={};
  // This contains an ordered list of ALL GeoJSON keys.
  var keys=[];
  // This contains a cascading viewport array,
  // initialized to one default element.
  var viewports=[{
    bbox: [-Infinity,-Infinity,Infinity,Infinity],
    prefix: [], // (limited) items returned by this viewport
    position: 0 // index from which to append remaining keys
  }];

  // check if accuracy is justified and replace GeoJSON if not
  function update_geometry(error) {
    var options={keys:[], error:error};
    for (var id in items)
      if (!items[id].keep || error<items[id].GeoJSON.error)
        options.keys.push(id);
    if (!options.keys.length) {
      call.that_last_one();
      return;
    }
    // timeout is 5ms or instantaneous
    var timeout = 5 * $("#settings [name='delayed']").prop('checked');
    list("geojson", options, function(data) {
      function update_one_geometry() {
        for (var id in data) {
          var item=data[id];
          var GeoJSON=item.GeoJSON;
          delete data[id];
          // Replace all 2-element arrays inside GeoJSON.coordinates with
          // LatLngs; This is written with extra-ugly comma operators and
          // multiple vars inside the for loop to increase performance. 
          var c=GeoJSON.coordinates;
          if (typeof(c[0])=="number") GeoJSON.coordinates=new LatLng(c[1],c[0]);
          else if (typeof(c[0][0])=="number")
            for (var i=0, ci; ci=c[i], i<c.length; i++) c[i]=new LatLng(ci[1],ci[0]);
          else if (typeof(c[0][0][0])=="number")
            for (var i=0, ci; ci=c[i], i<c.length; i++)
            for (var j=0, cij; cij=ci[j], j<ci.length; j++) ci[j]=new LatLng(cij[1],cij[0]);
          else if (typeof(c[0][0][0][0])=="number")
            for (var i=0, ci; ci=c[i], i<c.length; i++)
            for (var j=0, cij; cij=ci[j], j<ci.length; j++)
            for (var k=0, cijk; cijk=cij[k], k<cij.length; k++) cij[k]=new LatLng(cijk[1],cijk[0]);
          var options={
            map:map,
            position:GeoJSON.coordinates,
            path:GeoJSON.coordinates,
            paths:GeoJSON.coordinates,
            strokecolor: '#FF0000',
            fillColor: fillColors[item.docs[0].type],
            fillOpacity: 0.25
          };
          var shape=function(type) {
            // yes this is the new switch
            if (type=="Point") return new Maps.Marker(options);
            if (type=="Polygon") return new Maps.Polygon(options);
            if (type=="LineString") return new Maps.Polyline(options);
            // remind myself that this needs work!!!
            alert("OH NO POKEY AN UNKNOWN GEOJSON TYPE!!!");
          }(GeoJSON.type);
          // select link if user clicks on shape
          Maps.event.addListener(shape, 'click', function(href) {
            return function() {href.focus();};
          }(items[id].link.find('a').last()));
          // update link text to a meaningful title
          var hrefs=items[id].link.find('a');
          for (var d=0;d<item.docs.length;d++) {
            var doc=item.docs[d];
            $(hrefs[d]).html(doc.type+' '+doc[doc.type]);
          }
          if (items[id].shape) items[id].shape.setMap();
          // there is no need to keep all the polygons
          items[id].GeoJSON={error:GeoJSON.error};
          items[id].docs=item.docs;
          items[id].shape=shape;
          if (!timeout) continue
          window.setTimeout(update_one_geometry, timeout);
          return;
        }
        call.that_last_one();
      }
      update_one_geometry();
    });
  }

  // diff-updates items inside viewport
  function update_items(error) {
    var NE=map.getBounds().getNorthEast();
    var SW=map.getBounds().getSouthWest();
    var options={
      limit:parseFloat($("#settings [name='limit']").val()),
      error:error==null?(NE.lat()-SW.lat())/100:error,
      bbox:[SW.lng(),SW.lat(),NE.lng(),NE.lat()]
    };
    var vp;
    // pop viewports until one is found that surrounds bbox
    do vp=viewports.pop();
    while (options.bbox[0]<vp.bbox[0]||options.bbox[1]<vp.bbox[1]||
           options.bbox[2]>vp.bbox[2]||options.bbox[3]>vp.bbox[3]);
    // the last viewport is valid, so it needs to be re-stacked
    viewports.push(vp);
    // ignore items that were already dropped by previous viewport
    options.keys=vp.prefix.concat(keys.slice(vp.position));
    var details = $("#details")
    list("bbox", options, function(data) {
      // lists items to be removed as {id:null}
      var old_items={};
      for (var id in items) old_items[id]=null;
      // prepare new viewport
      var new_vp={ bbox:options.bbox, prefix:[] };
      // I need the last prop of data after the loop again. This is one
      // exceptional case where no 'var' is found in a for-statement.
      var id; for (id in data) {
        new_vp.prefix.push(id);
        if (items[id]) {
          items[id].keep=(items[id].GeoJSON.error===data[id].GeoJSON.error);
          delete old_items[id];
          continue;
        }
        items[id]=data[id];
        var link=$(document.createElement("li"));
        for (doc=0;doc<items[id].docs.length;doc++) {
          // Group docs with identical GIS into one li.
          if (doc) link.append("<br>");
          // Link to Futon for the lack of a better interface.
          link.append('<a target="_blank" href="/_utils/document.html?'+list.db+'/'
                       +items[id].docs[doc]._id+'">'+items[id].docs[doc]._id+'</a>');
        }
        details.append(link);
        items[id].link=link;
      }
      // If the query returned less than the required items, then these must
      // be the only items within the viewport. In this case the index may be
      // set to the end of the list, and no keys are appended.
      if (new_vp.prefix.length<options.limit) new_vp.position=keys.length;
      // In any other case it is safe to assume that any key before the
      // last one is either outside the viewport or already in prefix.
      else new_vp.position=keys.indexOf(id)+1;
      // Add new_vp to viewport stack, but only if it is indeed more restrictive.
      if (new_vp.position>vp.position || new_vp.prefix.length<vp.prefix.length)
        viewports.push(new_vp);
      // remove out-of-viewport shapes and links
      for (var id in old_items) {
        // shape is not guaranteed to be set because
        // _list/bbox-filter/geojson might be unsuccessful
        if (items[id].shape) items[id].shape.setMap();
        items[id].link.remove();
        delete items[id];
      }
      // Put a small delay between both lists to
      // let CouchDB recover from its previous crash.
      window.setTimeout(function() {update_geometry(options.error);}, 10);
    });
  }

  // initialize map position and geometry as soon as map has finished loading.
  Maps.event.addListenerOnce(map, 'tilesloaded', function() {
    // set viewport and zoom level
    $.getJSON("_view/dimensions", function(data) {
      var bbox=data.rows[0].value.bbox;
      map.setCenter(new LatLng((bbox[3]+bbox[1])/2.0, (bbox[2]+bbox[0])/2.0));
      //map.panToBounds(new LatLngBounds(new LatLng(bbox[1],bbox[0]),new LatLng(bbox[3],bbox[2])));
    });
    // get list of GeoJSON keys, largest to smallest item
    $.getJSON("_view/dimensions?reduce=false&descending=true", function(data) {
      for (var row=0;row<data.rows.length;row++)
        keys.push(data.rows[row].id);
      call.this_one_next(update_items)();
      // update GeoJSON according to viewport
      Maps.event.addListener(map, 'bounds_changed', call.this_one_next(update_items));
    });
    // get doc types and set colors
    $.getJSON("_view/types-fields?group_level=1", function(data) {
      // This is one rare advantage of javascripts 'phony' arrays:
      // I can use fillColors first as a set and then assign keys
      // to each element!! How nice!!!
      for (var row=0;row<data.rows.length;row++)
        fillColors[data.rows[row].key[0]]=fillColors.shift();
    });
    // cycle through geometric detail mode:
    // 'refine' <-> 'precise' -> 'simplified' -> 'refine'
    $("#settings [name='refine']").click( function() {
      $("#settings [name='refine']").hide();
      $("#settings [name='precise']").show();
      // show refined geometry once, and
      call.this_one_next(function() {update_geometry(0);})();
      // revert to 'refine', if viewport was moved
      Maps.event.addListenerOnce(map, 'bounds_changed', function() {
        $("#settings [name='precise']").hide();
        $("#settings [name='refine']").show();
      });
    });
    $("#settings [name='precise']").click( function() {
      $("#settings [name='precise']").hide();
      $("#settings [name='simplified']").show();
      Maps.event.clearListeners(map, 'bounds_changed');
      Maps.event.addListener(map, 'bounds_changed', call.this_one_next(function() {update_items(0);}));
    });
    $("#settings [name='simplified']").click( function() {
      $("#settings [name='simplified']").hide();
      $("#settings [name='refine']").show();
      Maps.event.clearListeners(map, 'bounds_changed');
      Maps.event.addListener(map, 'bounds_changed', call.this_one_next(update_items));
      Maps.event.trigger(map, 'bounds_changed');
    });
    // update map if limit was typed in by hand
    $("#settings").submit( function(e) {
      e.preventDefault();
      Maps.event.trigger(map, 'bounds_changed');
    });
    // increase limit to next higher [1,2,5,10,20,50,etc]
    $("#settings [name='more']").click( function() {
      var limit=parseFloat($("#settings [name='limit']").val());
      var new_limit=10;
      while (new_limit<=limit) new_limit*=10;
      if (new_limit>5*limit) new_limit/=5;
      if (new_limit>2*limit) new_limit/=2;
      $("#settings [name='limit']").val(new_limit);
      Maps.event.trigger(map, 'bounds_changed');
    });
    // decrease limit to next lower [1,2,5,10,20,50,etc]
    $("#settings [name='less']").click( function() {
      var limit=parseFloat($("#settings [name='limit']").val());
      var new_limit=1;
      while (new_limit*10<limit) new_limit*=10;
      if (new_limit*5<limit) new_limit*=5;
      if (new_limit*2<limit) new_limit*=2;
      $("#settings [name='limit']").val(new_limit);
      Maps.event.trigger(map, 'bounds_changed');
    });
  });

});
</script>

<style>
  #details a:focus {font-weight:bold}
  #settings .geometry-level {width:6em}
</style>

  </head>
  <body style="height:90%">

  <iframe src="login_bar.htm" style="width:100%; height:1.6em; border:0;"></iframe>

  <h1> Karte </h1>
  <form id="settings">
    Darstellung:
    <input type="button" name="refine" class="geometry-level" value="verfeinern">
    <input type="button" name="precise" class="geometry-level" value="exakt" style="display:none">
    <input type="button" name="simplified" class="geometry-level" value="vereinfacht" style="display:none">
    <input type="checkbox" name="delayed">verzögert
    <input type="text" name="limit" size=2 value="50"> Polygone
    <input type="button" value="weniger" name="less">
    <input type="button" value="mehr" name="more">
  </form>
  <div id="map" style="height:90%"></div>
  <ul id="details"></ul>
  </body>
</html>
