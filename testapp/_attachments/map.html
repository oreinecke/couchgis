<!DOCTYPE html>

<html lang="de" style="height:90%">
  <head>
    <title>Karte</title>
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8">

    <script src="script/jquery-1.10.2.js"></script>
    <script src="script/require.js"></script>
    <script type="text/javascript" src="https://maps.googleapis.com/maps/api/js?v=3.exp&sensor=false"></script>

<script type="text/javascript">
$(document).ready(function() {

  // stash frequently used objects here
  var Maps=google.maps;
  var LatLng=Maps.LatLng;
  var LatLngBounds=Maps.LatLngBounds;

  var map = new Maps.Map($('#map')[0], {
    zoom: 12,
    mapTypeId: Maps.MapTypeId.SATELLITE,
    center: new LatLng(50.83730534254573, 13.938310197234163)
  });

  var range=require('views/lib/range');

  // some nice colors for different types
  var fillColors=['#00FF80','#8000FF','#80FF00','#FF8000','#0080FF'];
  var types=[];

  // call _list/bbox-filter/<view> with some useful options
  function list(view, options, success) {
    var keys=(options.keys?'{"keys":["'+options.keys.join('","')+'"]}':"{}");
    options.keys=undefined;
    options.offset=list.offset;
    view+="?options="+encodeURIComponent(JSON.stringify(options));
    $.ajax("_list/bbox-filter/"+view, {
      type:"POST",
      dataType:"json",
      data:keys,
      success:success,
      error:call.that_last_one
    });
  }
  // ok this also looks retarded but it keeps my stuff in one place at least
  list.parts=window.location.pathname.match(/[^/]+/g);
  list.db=list.parts[0];
  list.app=list.parts[2];
  // correct for small shift in Google Maps aerials of unknown reason
  list.offset=[-0.00178,-0.00121];

  // It is very likely that the oftentimes inexperienced user clicks and
  // scrolls the map like an ape (on adderall). Then, event handler callbacks
  // will be fired all over the place and the interface probably won't react
  // anymore. It should be smarter than that; It should wait a couple of
  // seconds, then wait for the last ajax to complete, then do the next thing
  // that needs to be done.
  var call={
    now:null, next:null,
    this_one_next:function(what) {
      // We might as well do the closure here, because this
      // is used only for event handler registration anyway.
      return function() {
        if (call.now!==null) call.next=what;
        else (call.now=what)();
      }
    },
    that_last_one:function() {
      window.setTimeout(function() {
        call.now=call.next;
        call.next=null;
        if (call.now!==null) call.now();
      }, 500);
    },
    no_one:function() {
      call.now=null;
      call.next=null;
    }
  };
  // All items that are displayed on the map are in here as "id":{etc.}.
  var items={};
  // This contains an ordered list of ALL GeoJSON keys.
  var keys=[];
  // This contains a cascading viewport array,
  // initialized to one default element.
  var viewports=[{
    bbox: [-Infinity,-Infinity,Infinity,Infinity],
    prefix: [], // (limited) items returned by this viewport
    position: 0 // index from which to append remaining keys
  }];

  // query for GeoJSON and full documents
  function update_geometry() {
    var keys=[];
    for (var id in items) {
      if (items[id].keep) continue;
      keys.push([id,items[id].GeoJSON.error]);
      var docs=items[id].docs;
      for (var d=0;d<docs.length;d++)
        keys.push([id,docs[d]._id]);
    }
    if (!keys.length) {
      call.that_last_one();
      return;
    }
    var successful=false;
    function ajax() {
      $.ajax("_view/geojson", {
        type:"POST",
        data:'{"keys":'+JSON.stringify(keys)+'}',
        dataType:"json",
        success:success,
        complete:function() {
          // Sadly, this seems to be the only way to catch
          // CouchDB's internal server error or whatever this is.
          if (!successful)
            window.setTimeout(ajax, 50);
        }
      });
    }
    ajax();
    function success(data) {
      successful=true;
      // timeout is 5ms or instantaneous
      var timeout = 5 * $("#settings [name='delayed']").prop('checked');
      var offset = list.offset;
      function update_one_geometry() {
        while (data.rows.length) {
          var row=data.rows.shift();
          var item=items[row.key[0]];
          var GeoJSON=row.value.GeoJSON;
          // Replace all 2-element arrays inside GeoJSON.coordinates with
          // LatLngs; This is written with extra-ugly comma operators and
          // multiple vars inside the for loop to increase performance.
          var c=GeoJSON.coordinates;
          if (typeof(c[0])=="number") GeoJSON.coordinates=new LatLng(c[1]+offset[1],c[0]+offset[0]);
          else if (typeof(c[0][0])=="number")
            for (var i=0, ci; ci=c[i], i<c.length; i++) c[i]=new LatLng(ci[1]+offset[1],ci[0]+offset[0]);
          else if (typeof(c[0][0][0])=="number")
            for (var i=0, ci; ci=c[i], i<c.length; i++)
            for (var j=0, cij; cij=ci[j], j<ci.length; j++) ci[j]=new LatLng(cij[1]+offset[1],cij[0]+offset[0]);
          else if (typeof(c[0][0][0][0])=="number")
            for (var i=0, ci; ci=c[i], i<c.length; i++)
            for (var j=0, cij; cij=ci[j], j<ci.length; j++)
            for (var k=0, cijk; cijk=cij[k], k<cij.length; k++) cij[k]=new LatLng(cijk[1]+offset[1],cijk[0]+offset[0]);
          var options={
            map:map,
            position:GeoJSON.coordinates,
            path:GeoJSON.coordinates,
            paths:GeoJSON.coordinates,
            strokecolor: '#FF0000',
            fillOpacity: 0.25
          };
          var link=item.link;
          link.html('');
          for (var d=0;d<item.docs.length;d++) {
            // Group docs with identical GIS into one li.
            var doc=data.rows.shift().value.doc;
            if (options.fillColor) link.append('<br>');
            else options.fillColor=fillColors[doc.type];
            // Link to Futon for the lack of a better interface
            // and set link text to a useful item explanation.
            link.append('<a target="_blank" href="/_utils/document.html?'+list.db+'/'+d+'">'
                                     +doc.type+' '+doc[doc.type]+' ('+range.toString(doc.time)+')</a>');
          }
          var shape=function(type) {
            // yes this is the new switch
            if (type=="Point") return new Maps.Marker(options);
            if (type=="Polygon") return new Maps.Polygon(options);
            if (type=="LineString") return new Maps.Polyline(options);
            // remind myself that this needs work!!!
            alert("OH NO POKEY AN UNKNOWN GEOJSON TYPE!!!");
          }(GeoJSON.type);
          // Select link if user clicks on shape and decrease
          // zIndex to give access to obstructed shapes.
          Maps.event.addListener(shape, 'click', function(href) {
            return function() {
              this.setOptions({zIndex:-new Date().getTime()});
              href.focus();
            };
          }(item.link.find('a').last()));
          if (item.shape) item.shape.setMap();
          item.shape=shape;
          if (!timeout) continue
          window.setTimeout(update_one_geometry, timeout);
          return;
        }
        call.that_last_one();
      }
      update_one_geometry();
    }
  }

  // diff-updates items inside viewport
  function update_items(error) {
    var NE=map.getBounds().getNorthEast();
    var SW=map.getBounds().getSouthWest();
    var options={
      limit:parseFloat($("#settings [name='limit']").val()),
      error:error==null?(NE.lat()-SW.lat())/100:error,
      bbox:[SW.lng(),SW.lat(),NE.lng(),NE.lat()],
      types:[]
    };
    // read checked types off the filter form
    var checkboxes=$("#filter .types").find(':checkbox');
    for (var c=0;c<checkboxes.length;c++)
      if ($(checkboxes[c]).prop('checked'))
        options.types.push(types[c]);
    // remove type check if all are allowed
    if (options.types.length==types.length)
      delete options.types;
    // add time constraint if specified
    options.time=$("#filter [name='time']").val();
    if (options.time=="")
      delete options.time;
    var vp;
    // pop viewports until one is found that surrounds bbox
    do vp=viewports.pop();
    while (options.bbox[0]<vp.bbox[0]||options.bbox[1]<vp.bbox[1]||
           options.bbox[2]>vp.bbox[2]||options.bbox[3]>vp.bbox[3]);
    // the last viewport is valid, so it needs to be re-stacked
    viewports.push(vp);
    // ignore items that were already dropped by previous viewport
    options.keys=vp.prefix.concat(keys.slice(vp.position));
    var details = $("#details")
    list("bbox", options, function(data) {
      // lists items to be removed as {id:null}
      var old_items={};
      for (var id in items) old_items[id]=null;
      // prepare new viewport
      var new_vp={ bbox:options.bbox, prefix:[] };
      // I need the last prop of data after the loop again. This is one
      // exceptional case where no 'var' is found in a for-statement.
      var id; for (id in data) {
        new_vp.prefix.push(id);
        if (items[id]) {
          delete old_items[id];
          var keep=( items[id].GeoJSON.error===data[id].GeoJSON.error
                    && items[id].docs.length===data[id].docs.length );
          var old_docs=items[id].docs, docs=data[id].docs;
          for (var d=0; keep && d<docs.length; d++)
            keep &= (old_docs[d]._id===docs[d]._id);
          items[id].keep=keep;
          items[id].GeoJSON=data[id].GeoJSON;
          items[id].docs=docs;
          continue;
        }
        items[id]=data[id];
        var link=$(document.createElement("li"));
        details.append(link);
        items[id].link=link;
      }
      // If the query returned less than the required items, then these must
      // be the only items within the viewport. In this case the index may be
      // set to the end of the list, and no keys are appended.
      if (new_vp.prefix.length<options.limit) new_vp.position=keys.length;
      // In any other case it is safe to assume that any key before the
      // last one is either outside the viewport or already in prefix.
      else new_vp.position=keys.indexOf(id)+1;
      // Add new_vp to viewport stack, but only if it is indeed more restrictive.
      if (new_vp.position>vp.position || new_vp.prefix.length<vp.prefix.length)
        viewports.push(new_vp);
      // remove out-of-viewport shapes and links
      for (var id in old_items) {
        // shape is not guaranteed to be set because
        // _list/bbox-filter/geojson might be unsuccessful
        if (items[id].shape) items[id].shape.setMap();
        items[id].link.remove();
        delete items[id];
      }
      // Put a small delay between both lists to
      // let CouchDB recover from its previous crash.
      update_geometry();
    });
  }

  // Initialize map position and geometry as soon as map has finished loading.
  Maps.event.addListenerOnce(map, 'tilesloaded', function() {
    // set viewport and zoom level
    $.getJSON("_view/dimensions", function(data) {
      var bbox=data.rows[0].value.bbox;
      map.setCenter(new LatLng((bbox[3]+bbox[1])/2.0, (bbox[2]+bbox[0])/2.0));
      //map.panToBounds(new LatLngBounds(new LatLng(bbox[1],bbox[0]),new LatLng(bbox[3],bbox[2])));
    });
    // get list of GeoJSON keys, largest to smallest item
    $.getJSON("_view/dimensions?reduce=false&descending=true", function(data) {
      for (var row=0;row<data.rows.length;row++)
        keys.push(data.rows[row].id);
      call.this_one_next(update_items)();
      // update GeoJSON according to viewport
      Maps.event.addListener(map, 'bounds_changed', call.this_one_next(update_items));
    });
    // get doc types and set colors
    $.getJSON("_view/types-fields?group_level=1", function(data) {
      // This is one rare advantage of javascripts 'phony' arrays:
      // I can use fillColors first as a set and then assign keys
      // to each element!! How nice!!!
      var span=$("#filter .types");
      for (var row=0;row<data.rows.length;row++) {
        var type=data.rows[row].key[0];
        types.push(type);
        fillColors[type]=fillColors.shift();
        span.append('<input type="checkbox" checked>');
        span.append(type);
      }
      // update items if filters have changed
      $("#filter").change( function() {
        // Check if the new filter setting is more restrictive than the old
        // one. I am doing this kind-a handwavingly by just counting the
        // allowed doc types and comparing my new count to the old one. Anyone
        // capable of un-checking and checking checkboxes really fast will find
        // this quirky to use.
        var last_number_of_types=types.length;
        var last_range=range.toRange($("#filter [name='time']").val());
        return function() {
          var this_number_of_types=0;
          span.find(":checkbox").each(function() {
            this_number_of_types+=$(this).prop('checked');
          });
          // If new filters aren't more restrictive, my viewport
          // array is rendered invalid and needs to be rebuilt.
          if (this_number_of_types>last_number_of_types)
            viewports=[viewports[0]];
          last_number_of_types=this_number_of_types;
          // Same holds for time range.
          var this_range=range.toRange($("#filter [name='time']").val());
          if (!range.contains(last_range, this_range));
            viewports=[viewports[0]];
          last_range=this_range;
          Maps.event.trigger(map, 'bounds_changed');
        }
      }());
    });
    // cycle through geometric detail mode:
    // 'refine' <-> 'precise' -> 'simplified' -> 'refine'
    $("#settings [name='refine']").click( function() {
      $("#settings [name='refine']").hide();
      $("#settings [name='precise']").show();
      // show refined geometry once, and
      for (var id in items)
        items[id].GeoJSON.error=items[id].keep=0;
      call.this_one_next(update_geometry)();
      // revert to 'refine', if viewport was moved
      Maps.event.addListenerOnce(map, 'bounds_changed', function() {
        $("#settings [name='precise']").hide();
        $("#settings [name='refine']").show();
      });
    });
    $("#settings [name='precise']").click( function() {
      $("#settings [name='precise']").hide();
      $("#settings [name='simplified']").show();
      Maps.event.clearListeners(map, 'bounds_changed');
      Maps.event.addListener(map, 'bounds_changed', call.this_one_next(function() {update_items(0);}));
    });
    $("#settings [name='simplified']").click( function() {
      $("#settings [name='simplified']").hide();
      $("#settings [name='refine']").show();
      Maps.event.clearListeners(map, 'bounds_changed');
      Maps.event.addListener(map, 'bounds_changed', call.this_one_next(update_items));
      Maps.event.trigger(map, 'bounds_changed');
    });
    // increase limit to next higher [1,2,5,10,20,50,etc]
    $("#settings [name='more']").click( function() {
      var limit=parseFloat($("#settings [name='limit']").val());
      var new_limit=10;
      while (new_limit<=limit) new_limit*=10;
      if (new_limit>5*limit) new_limit/=5;
      if (new_limit>2*limit) new_limit/=2;
      $("#settings [name='limit']").val(new_limit);
      Maps.event.trigger(map, 'bounds_changed');
    });
    // decrease limit to next lower [1,2,5,10,20,50,etc]
    $("#settings [name='less']").click( function() {
      var limit=parseFloat($("#settings [name='limit']").val());
      var new_limit=1;
      while (new_limit*10<limit) new_limit*=10;
      if (new_limit*5<limit) new_limit*=5;
      if (new_limit*2<limit) new_limit*=2;
      $("#settings [name='limit']").val(new_limit);
      Maps.event.trigger(map, 'bounds_changed');
    });
    // Suppress page load if user presses enter in any
    // text input and update map if anything changed.
    $("#settings").change( function(e) {
      Maps.event.trigger(map, 'bounds_changed');
    });
    $("form").submit( function(e) {e.preventDefault();} );
  });

});
</script>

<style>
  #details a:focus {font-weight:bold}
  #settings .geometry-level {width:6em}
</style>

  </head>
  <body style="height:90%">

  <iframe src="login_bar.htm" style="width:100%; height:1.6em; border:0;"></iframe>

  <h1> Karte </h1>
  <form id="settings">
    Darstellung:
    <input type="button" name="refine" class="geometry-level" value="verfeinern">
    <input type="button" name="precise" class="geometry-level" value="exakt" style="display:none">
    <input type="button" name="simplified" class="geometry-level" value="vereinfacht" style="display:none">
    <input type="checkbox" name="delayed">verzögert
    <input type="text" name="limit" size=2 value="50"> Polygone
    <input type="button" value="weniger" name="less">
    <input type="button" value="mehr" name="more">
  </form>
  <div id="map" style="height:90%"></div>
  <form id="filter"> Filter:
    <span class="types"></span>
    <input type="text" size=8 value="2004-2013" name="time" title="Zeit"><br>
  </form>
  <ul id="details"></ul>
  </body>
</html>
