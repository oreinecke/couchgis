<!DOCTYPE html>

<html lang="de" style="height:90%">
  <head>
    <title>Karte</title>
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8">

    <script src="script/jquery-1.10.2.js"></script>
    <script src="script/jquery.couch.js"></script>
    <script src="script/login_bar.js"></script>
    <script type="text/javascript" src="https://maps.googleapis.com/maps/api/js?v=3.exp&sensor=false"></script>

<script type="text/javascript">
$(document).ready(function() {

  // stash frequently used objects here
  var Maps=google.maps;
  var LatLng=Maps.LatLng;
  var LatLngBounds=Maps.LatLngBounds;

  var map = new Maps.Map(document.getElementById('map'), {
    zoom: 14,
    mapTypeId: Maps.MapTypeId.SATELLITE,
    center: new LatLng(50.83730534254573, 13.938310197234163)
  });

  MAP=map; // remove me!! I am just for the FF js shell

  var list=function() {
    var parts=window.location.pathname.match(/[^/]+/g);
    var db=$.couch.db(parts[0]);
    var app=parts[2];
    return function(view, data, options) {
      return db.list(app+"/bbox-filter", view, data, options);
    }
  }();

  // It is very likely that the oftentimes inexperienced user clicks and
  // scrolls the map like an ape (on adderall). Then, event handler callbacks
  // will be fired all over the place and the interface probably won't react
  // anymore. It should be smarter than that; It should wait a couple of
  // seconds, then wait for the last ajax to complete, then do the next thing
  // that needs to be done. 
  var call={
    now:null, next:null,
    this_one_next:function(what) {
      if (call.now!==null) call.next=what;
      else (call.now=what)();
    },
    that_last_one:function() {
      window.setTimeout(function() {
        call.now=call.next;
        call.next=null;
        if (call.now!==null) call.now();
      }, 500);
    }
  };
  // All items that are displayed on the map are in here as "id":{etc.}.
  var items={};
  // This contains a partially ordered list of GeoJSON ids for list().
  var keys={
    prefix:[],
    sorted:[] 
  };

  // check if accuracy is justified and replace GeoJSON if not
  function update_geometry(error) {
    var keys=[];
    for (var id in items)
      if (!items[id].keep || items[id].GeoJSON.error<=error)
        keys.push(id);
    if (!keys.length) {
      call.that_last_one();
      return;
    }
    list("geojson", {keys:keys, error:error}, {success:function(data) {
      function update_one_geometry() {
        for (var id in data) {
          var item=data[id];
          var GeoJSON=item.GeoJSON;
          delete data[id];
          var paths=[];
          // remind myself that this needs work!!!
          if (GeoJSON.type!="Polygon") { alert("OH NO POKEY AN UNKNOWN GEOJSON TYPE!!!"); return; }
          for (var path=0;path<GeoJSON.coordinates.length;path++) {
            paths.push([]);
            var coords=GeoJSON.coordinates[path];
            for (var coord=0;coord<coords.length;coord++)
              paths[path].push(new LatLng(coords[coord][1], coords[coord][0]));
          }
          var shape=new Maps.Polygon({ paths:paths, fillOpacity: 0.25, fillColor: '#00FF80' });
          shape.setMap(map);
          if (items[id].shape)
            items[id].shape.setMap();
          // there is no need to keep all the polygons
          items[id]={
            GeoJSON: { error: item.GeoJSON.error },
            docs: item.docs, shape: shape
          }
          window.setTimeout(update_one_geometry, 50);
          return;
        }
        call.that_last_one();
      }
      update_one_geometry();
    }});
  }

  // diff-updates items inside viewport
  function update_items() {
    var NE=map.getBounds().getNorthEast();
    var SW=map.getBounds().getSouthWest();
    var options={
      keys:keys.prefix.concat(keys.sorted),
      unsorted:keys.prefix.length,
      limit:50,
      error:(NE.lat()-SW.lat())/100,
      bbox:[SW.lng(),SW.lat(),NE.lng(),NE.lat()]
    };
    list("bbox-size", options, {success:function(data) {
      // lists items to be removed as {id:null}
      var old_items={};
      for (var id in items) old_items[id]=null;
      var new_prefix=[];
      var new_geometry=[];
      for (var id in data) {
        if (items[id]==null) items[id]=data[id];
        else items[id].keep=(items[id].GeoJSON.error===data[id].GeoJSON.error)
        delete old_items[id];
        // update prefix and sorted 'keys' component:
        // i) new ids are placed in front 
        new_prefix.push(id);
        var j=keys.prefix.indexOf(id);
        // ii) and removed from keys.prefix
        if (j>=0) keys.prefix.splice(j,1);
        // iii) or from the sorted tail
        else keys.sorted.splice(keys.sorted.indexOf(id),1);
      }
      keys.prefix=new_prefix.concat(keys.prefix);
      for (var id in old_items) {
        if (items[id].shape)
          items[id].shape.setMap();
        delete items[id];
      }
      update_geometry(options.error);
    }});
  }

  // initialize map position and geometry as soon as map has finished loading.
  Maps.event.addListenerOnce(map, 'tilesloaded', function() {
    // The key initialization should probably happen here: we just need a query
    // that yields an ordered id list and a bbox as union of all bboxes or at
    // least a center to point the map to.
    list("bbox-size", {}, {success:function(data) {
      for (var id in data) {
        items[id]=data[id];
        keys.sorted.push(id);
      }
      update_items();
      // update GeoJSON according to viewport here.
      Maps.event.addListener(map, 'bounds_changed', function() {call.this_one_next(update_items);} );
      $("#settings [name='refine']").click(function() {
        console.log("!!!");
        call.this_one_next(function() {
          update_geometry(0);
        })
      });
    }});
  });

});
</script>

  </head>
  <body style="height:90%">

  <iframe src="login_bar.htm" style="width:100%; height:1.4em; border:0;"></iframe>

  <h1> Karte </h1>
  <form id="settings">
    Darstellung:
    <input type="button" name="refine" value="verfeinern">
  </form>
  <div id="map" style="height:90%"></div>

  </body>
</html>
