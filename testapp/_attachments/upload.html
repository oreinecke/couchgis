<!DOCTYPE html>

<html lang="de" style="height:100%">
  <head>
    <title>XML/GeoJSON-Upload</title>
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8">
    <link href="css/jquery-ui-1.10.4.custom.css" rel="stylesheet">
    <script src="script/jquery-1.10.2.js"></script>
    <script src="script/jquery-ui-1.10.4.custom.js"></script>
    <script src="script/jquery.couch.js"></script>
    <script type="text/javascript" src="https://maps.googleapis.com/maps/api/js?v=3.15&sensor=false"></script>
    <script src="script/google.maps.js"></script>

<script>
$(document).ready(function() {
  var db=window.location.pathname.match(/[^/]+/)[0];
  var map;
  var crs, features=[];
  var submit=$("#upload :submit");
  var revert=$("#upload :button");
  var fields={};
  var values={};
  // doc ids and revisions from _bulk_docs response
  var uploaded_docs;
  $.getJSON("_view/fields-values?group_level=1", function(data) {
    var source=[];
    while (data.rows.length)
      source.push(data.rows.shift().key[0]);
    $("#modify [name='type']").autocomplete({
      source:source, minLength:0,
      change:function() {$(this).change();}
    });
    $("#modify [name='type']").autocomplete({ source:source, minLength:0 });
  });
  $("#modify [name='type']").change( function() {
    var key="start_key="+encodeURIComponent(JSON.stringify([$(this).val()])) +
             "&end_key="+encodeURIComponent(JSON.stringify([$(this).val()+' ']));
    // Suggest these common field names:
    var source=[
      { label:"Datensatz-Typ", value:"type", mixed:true },
      { label:"Zeitraum", value:"time" }
    ];
    $.getJSON("_view/fields-values?group_level=2&"+key, function(data) {
      while (data.rows.length)
        source.push(data.rows.shift().key[1]);
      $("#modify [name='field']").autocomplete({
        minLength:0, source:source,
        change:function() {$(this).change();}
      });
    });
    // Suggest that our new documents should also have
    // a field named <doc.type> but do not enforce it.
    $("#description-field").html($(this).val()||undefined);
  // In case type already has a value; FireFox
  // 26.0 does not clear inputs on page reload.
  }).change();
  $("#description-include").change( function() {
    $("#description-value").prop('disabled', !$(this).prop('checked'));
  });
  function show_feature(f) {
    $("#modify a").html(f+1);
    var properties=features[f].properties;
    for (var prop in properties)
      values[prop].val(properties[prop]).attr('title', properties[prop]);
  }
  $("#upload :file").change(function(e) {
    $("#modify").hide();
    $("#reduce [name='show']").show();
    $("#reduce span").hide();
    submit.prop('disabled', true);
    $("#upload b").html("");
    var reader=new FileReader();
    // get file type and be flexible about extensions
    var filetype=e.target.files[0].name.match(/[^.]*$/)[0];
    if (/^(geojson|json)$/i.test(filetype)) filetype="geojson";
    if (/^xml$/i.test(filetype)) filetype="xml";
    reader.onload=function(evt) {
      try {
        if (filetype==="geojson") {
          var GeoJSON;
          // reformat JSON.parse error merrages
          try { GeoJSON=JSON.parse(evt.target.result); }
          catch (err) { throw{message:"JSON.parse: "+err.message}; }
          if (GeoJSON.type=="FeatureCollection") features=GeoJSON.features;
          else if (GeoJSON.type=="Feature") features=[GeoJSON];
          else throw{message:"Unknown or useless GeoJSON type: "+GeoJSON.type};
          crs=GeoJSON.crs;
          if (!crs) throw{message:"No top-level CRS defined"};
        } else if (filetype==="xml") {
          // divide xml recursively into <Tag>..</Tag> objects
          var tables=(function parse(xml, tags) {
            if (typeof tags==="object") {
              if (!tags.length) return xml;
              var tag=tags[0];
              var elements=parse(xml, tag);
              for (var i=0;i<elements.length;i++)
                elements[i].xml=parse(elements[i].xml, tags.slice(1));
              return elements;
            }
            var elements=[], tag=tags, m;
            do {
              // match opening <Tag> or singular <Tag/>
              if (!(m=xml.match('<\\s*'+tag+'(/?>|\\s[^>]*>)')))
                continue;
              // parse tag attributes
              var attribs=m[0].match(/[\w:]+="[^"]*"/g);
              var element={};
              while (attribs && attribs.length) {
                var attrib=attribs.shift().match(/([\w:]+)="([^"]*)"/);
                element[attrib[1]]=attrib[2];
              }
              if (m[0].search('/>$')===-1) {
                // strip matched tag from xml
                xml=xml.substring(m.index+m[0].length);
                // match closing </Tag>
                if (!(m=xml.match('</\\s*'+tag+'\\s*>')))
                  throw({message:"XML.parse: Missing </"+tag+">"});
                // add xml between <Tag>..</Tag>
                element.xml=xml.substring(0,m.index);
              // add empty xml if <Tag/> is singular
              } else element.xml="";
              elements.push(element);
              // strip processed xml and continue
              xml=xml.substring(m.index+m[0].length);
            } while (m);
            return elements;
          })(evt.target.result, ["Table","Row","Cell","Data"]);
          while (tables.length) {
            var rows=tables.shift().xml;
            // insert empty xml if ss:Index is set
            function normalize(xml) {
              for (var i=0;i<xml.length;i++)
                while ( i+1 < (xml[i]['ss:Index'] || 0) )
                  xml.splice(i++, 0, {xml:[]});
              return xml;
            }
            var columns=normalize(rows.shift().xml);
            while (rows.length) {
              var row=normalize(rows.shift().xml);
              var properties={};
              for (var c=0;c<row.length;c++) {
                if (!columns[c].xml.length) continue;
                var data=row[c].xml[0] || {xml:""};
                if (data['ss:Type']==="Number") data.xml=parseFloat(data.xml);
                if (data['ss:Type']==="Boolean") data.xml=(data.xml==="1");
                properties[columns[c].xml[0].xml]=data.xml;
              }
              features.push({properties:properties});
            }
          }
        } else throw{message:"Unknown extension: ."+filetype};
        uploaded_docs={};
        for (var f=0;f<features.length;f++) {
          var properties=features[f].properties;
          // store previous version of existing document
          if (properties._id) $.getJSON('/'+db+'/'+properties._id, function(data) {
            uploaded_docs[data._id]=data;
          });
          // condense union of properties into the first feature
          if (!f) continue;
          for (var prop in properties)
            if (!(prop in properties))
              features[0].properties[prop]=undefined;
        }
      } catch(err) {
        $("#upload b").html(err.message+"<br>");
        return;
      }
      submit.prop('disabled', false);
      submit.val("Los!");
      var div=$("#modify div");
      fields={};
      values={};
      div.html("");
      // expect all property sets to be identical to the first one
      for (var prop in features[0].properties) {
        var row=$("<span>");
        // render field: value input pair
        var checkbox=$('<input type="checkbox" name="include" checked>');
        var field=$('<input type="text" name="field">');
        var value=$('<input type="text" name="value">');
        row.append(checkbox).append(field).append(': ').append(value).append('<br>');
        // write new value to selected data set
        value.change(function(input, prop) {
          return function() {
            var v=input.val();
            // try to parse new value as number
            try {
              v=JSON.parse(v);
              input.val(v);
            // if that fails just write it as a string
            } catch(err) {}
            features[$("#modify a").html()-1].properties[prop]=v;
          };
        }(value, prop));
        values[prop]=value;
        field.val(prop);
        fields[prop]=field;
        // disable input fields on row if unchecked
        checkbox.change(function(checkbox, field, value, prop) {
          return function() {
            var disabled=!checkbox.prop('checked');
            field.prop('disabled', disabled);
            value.prop('disabled', disabled);
            // set a nice and helpful tooltip
            var title=prop+' '
            if (disabled) title+='ignorieren';
            else {
              if (field.val()!=prop) title+='als "'+field.val()+'" ';
              title+='übernehmen';
            }
            checkbox.prop('title',title);
          };
        }(checkbox, field, value, prop));
        checkbox.change();
        field.change(function(checkbox) {
          return function() { checkbox.change(); };
        }(checkbox));
        div.append(row);
      }
      show_feature(0);
      $("#modify").show();
    };
    reader.readAsText(e.target.files[0]);
  });
  $("#modify").submit(function(e) {e.preventDefault();});
  // check/uncheck all
  $("#modify [name='all']").change(function() {
    $("#modify :checkbox").prop('checked', $(this).prop('checked'));
    $("#modify [name='include']").change();
  });
  $("#modify [name='prev']").click(function() {
    var f=$("#modify a").html();
    if (--f<1) f=features.length;
    show_feature(f-1);
  });
  $("#modify [name='next']").click(function() {
    var f=$("#modify a").html();
    if (++f>features.length) f=1;
    show_feature(f-1);
  });
  // compile fearures into document array
  $("#upload").submit(function(e) {
    var type=$("#modify [name='type']").val();
    var time=$("#modify [name='time']").val();
    var docs=[];
    for (var f=0;f<features.length;f++) {
      var feature=features[f];
      var doc=uploaded_docs[feature.properties._id] || {};
      // set doc-type and time
      doc.type=type || doc.type || undefined;
      doc.time=time || doc.time || undefined;
      // save document description as doc[doc.type]
      if ($("#description-include").prop('checked') && doc.type)
        doc[doc.type]=$("#description-value").val() || doc[doc.type] || undefined;
      // write properties with adjusted labels
      for (var prop in feature.properties) {
        if (fields[prop].prop('disabled')) continue;
        if (fields[prop].val()=="") continue;
        // and ignore useless undefined fields
        if ([null, "", "null", "undefined"].indexOf(feature.properties[prop])!==-1)
          doc[fields[prop].val()]=undefined;
        else doc[fields[prop].val()]=feature.properties[prop];
      }
      // Use either the newly defined GeoJSON_clone or the previous
      // one. Update the geometry itself only if none is referenced.
      if (!doc.GeoJSON_clone) {
        doc.GeoJSON=feature.geometry;
        doc.GeoJSON.crs=crs;
      }
      // Remove GeoJSON_clone if it references itself.
      if (doc.GeoJSON_clone===doc._id) delete doc.GeoJSON_clone;
      docs.push(doc);
    }
    $.couch.db(db).bulkSave( {docs:docs}, { success:function(data) {
      $("#modify").hide();
      $("#reduce").show();
      map = map || new Maps.Map($('#map')[0], {
        zoom: 17, mapTypeId: Maps.MapTypeId.SATELLITE,
        center: new LatLng(50.83730534254573, 13.938310197234163)
      });
      submit.hide();
      revert.show();
      uploaded_docs=data;
    }});
    e.preventDefault();
  });
  revert.click(function() {
    // stage docs for deletion
    for (var d=0;d<uploaded_docs.length;d++) {
      var doc=uploaded_docs[d];
      uploaded_docs[d]={
        _id:doc.id,
        _rev:doc.rev,
        _deleted:true
      };
    }
    $.couch.db(db).bulkSave( {docs:uploaded_docs}, { success:function(data) {
      submit.show();
      revert.hide();
      $("#modify").show();
      $("#reduce").hide();
    }});
  });
  function show_geometry(f) {
    // remove previous shapes from map canvas
    var feature=features[$("#show-suggestions a").html()-1];
    if (feature) {
      if (feature.shape) feature.shape.setMap();
      delete feature.shape;
      for (var id in feature.items) {
        if (feature.items[id].shape) feature.items[id].shape.setMap();
        delete feature.items[id].shape;
      }
    }
    $("#show-suggestions a").html(f+1);
    var keys=[];
    feature=features[f];
    keys.push([uploaded_docs[f].id, 0]);
    if (feature.items) for (var id in feature.items)
      keys.push([id, 0]);
    $("#reduce :button").prop('disabled', true);
    $.post("_view/geojson", JSON.stringify({keys:keys}), function(data) {
      $("#reduce :button").prop('disabled', false);
      data=JSON.parse(data);
      function select_me(GeoJSON_clone) {
        return function() {
          feature.properties.GeoJSON_clone=GeoJSON_clone;
          shape.setOptions({strokeColor:"#000000"});
          this.setOptions({strokeColor:"#FF0000", zIndex:-new Date().getTime()});
          shape=this;
          $("#clone-from b").html(GeoJSON_clone);
          var spans={ true: $("#clone-from"), false: $("#create-new") };
          spans[!GeoJSON_clone].hide();
          spans[!!GeoJSON_clone].show();
        };
      }
      while (data.rows.length) {
        var row=data.rows.shift();
        var GeoJSON_clone=row.key[0];
        if (row.key[0]===uploaded_docs[f].id)
          GeoJSON_clone=undefined;
        var GeoJSON=row.value.GeoJSON;
        var shape=create_shape(GeoJSON.type, expand_options({
          fillColor:GeoJSON_clone?"#0000FF":"#00FF00",
          map:map, coordinates: GeoJSON.coordinates
        }));
        shape.addListener('click', select_me(GeoJSON_clone));
        if (GeoJSON_clone) feature.items[row.key[0]].shape=shape;
        else feature.shape=shape;
      }
      map.setCenter(new LatLng((feature.bbox[3]+feature.bbox[1])/2.0+offset[1],
                               (feature.bbox[2]+feature.bbox[0])/2.0+offset[0]));
      if (feature.properties.GeoJSON_clone==null) shape=feature.shape;
      else shape=feature.items[feature.properties.GeoJSON_clone].shape;
      select_me(feature.properties.GeoJSON_clone).apply(shape);
    });
  }
  // skip to next/previous document with similar geometry
  $("#reduce [name='next']").click(function() {
    var f=$("#show-suggestions a").html()-1, g=f;
    do f=(f+1)%features.length;
    while (!features[f].items && f!=g);
    show_geometry(f);
  });
  $("#reduce [name='prev']").click(function() {
    var f=$("#show-suggestions a").html()-1, g=f;
    do f=(f+features.length-1)%features.length;
    while (!features[f].items && f!=g);
    show_geometry(f);
  });
  // query for similar geometry
  $("#reduce [name='show']").click(function() {
    $(this).hide();
    $("#show-suggestions").show();
    var keys=[];
    for (var d=0;d<uploaded_docs.length;d++)
      keys.push(features[d].properties.GeoJSON_clone || uploaded_docs[d].id);
    $.post("_list/bbox-filter/bbox", JSON.stringify({keys:keys}), function(data) {
      var i=0;
      for (var id in data) {
        var feature=features[i];
        feature.bbox=data[id].GeoJSON.bbox;
        var options=encodeURIComponent(JSON.stringify({
          bbox:feature.bbox,
          similarity:0.0001
        }));
        var found_geometry=function() {
          $("#reduce :button").prop('disabled', false);
          $("#reduce [name='next']").click();
          found_geometry=function() {};
        }
        $.getJSON("_list/bbox-filter/bbox?options="+options, function(id, i) {
          return function(data) {
            // remove from items if geometry is new
            if (id===uploaded_docs[i].id)
              delete data[id];
            // This leaves doc.items undefined if data is
            // empty or consists only of the cloned geometry.
            for (var id2 in data) {
              if (id2===id) continue;
              features[i].items=data;
              found_geometry();
              return;
            }
          };
        }(id, i++));
      }
    });
  });

});
</script>

<style>
  #modify span {white-space:nowrap}
  #modify div span {white-space:normal}
</style>

  </head>
  <body style="height:100%">

  <iframe src="login_bar.htm" style="width:100%; height:1.6em; border:0;"></iframe>

  <h1> XML/GeoJSON-Upload </h1>
  <form id="upload">
    <input type="file">
    <input type="submit" value="Los!" disabled>
    <input type="button" value="Rückgängig" name="revert" style="display:none"><br>
    <b></b>
  </form>
  <form id="modify" style="display:none">
    <span>Datensatz-Typ: <input type="text" name="type" size="10" value=""></span>
    <span>Zeitraum: <input type="text" name="time" size="15" value="06/2010-10.4.2012"></span><br>
    <span><input type="checkbox" name="all" checked> Alle Felder auswählen</span>
    <span><input type="button" name="prev" value="<">
      Datensatz <a>1</a>
      <input type="button" name="next" value=">"></span><br>
    <input id="description-include" type="checkbox" checked>
    <b id="description-field">&lt;Datensatz-Typ&gt;</b><b>:</b>
    <input id="description-value" type="text">
    <div></div>
    <span><input type="checkbox" name="all" checked> Alle Felder auswählen</span>
    <span><input type="button" name="prev" value="<">
      Datensatz <a>1</a>
      <input type="button" name="next" value=">"></span>
  </form>
  <form id="reduce" style="display:none;height:50%">
    <input type="button" name="show" value="Ähnliche Geometrien suchen">
    <span id="show-suggestions" style="display:none">
      Ähnliche Geometrien für
      <input type="button" name="prev" value="<" disabled>
      Datensatz <a>0</a>
      <input type="button" name="next" value=">" disabled>
    </span>
    <div id="map" style="height:100%"></div>
    <span id="create-new" style="display:none">Geometrie wird neu angelegt.</span>
    <span id="clone-from" style="display:none">Geometrie von Datensatz <b></b> verwenden.</span>
  </form>
  </body>
</html>
