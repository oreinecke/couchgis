<!DOCTYPE html>

<html lang="de" style="height:100%">
  <head>
    <title>XML/GeoJSON-Upload</title>
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8">
    <link href="css/jquery-ui-1.10.4.custom.css" rel="stylesheet">
    <script src="script/jquery-1.11.1.min.js"></script>
    <script src="script/jquery-ui-1.10.4.custom.js"></script>
    <script src="script/jquery.couch.js"></script>
    <script src="script/require.js"></script>
    <script type="text/javascript" src="https://maps.googleapis.com/maps/api/js?v=3.16&sensor=false"></script>
    <script src="script/google.maps.js"></script>

<script>
$(document).ready(function() {

  var path=require('views/lib/path');
  var db=window.location.pathname.match(/[^/]+/)[0];
  var map;
  var features=[];
  var submit=$("#upload :submit");
  var revert=$("#upload :button");
  var fields={};
  var values={};
  // doc ids and revisions from _bulk_docs response
  var uploaded_docs;
  $.getJSON("_view/type-year?group_level=1", function(data) {
    var source=[];
    while (data.rows.length)
      source.push( data.rows.shift().key.pop() );
    $("#modify [name=type]").autocomplete({
      source:source, minLength:0,
      change:function() {$(this).change();}
    });
  });

  $("#modify [name=type]").change( function() {
    // Suggest these common field names:
    var source=[
      { label:"Datensatz-Typ", value:"type", mixed:true },
      { label:"Zeitraum", value:"time" }
    ];
    $.getJSON("_view/fields-values", {
      group_level:2, descending:true,
      start_key:JSON.stringify([ $(this).val()+' ' ]),
      end_key:JSON.stringify([ $(this).val() ])
    }, function(data) {
      while (data.rows.length)
        source.push( data.rows.pop().key.pop() );
      $("#modify [name=field]").autocomplete({
        minLength:0, source:source,
        change:function() {$(this).change();}
      });
    });
    // Suggest that our new documents should also have
    // a field named <doc.type> but do not enforce it.
    $("#description-field").html($(this).val()||undefined);
  // In case type already has a value; FireFox
  // 26.0 does not clear inputs on page reload.
  }).change();

  $("#description-include").change( function() {
    $("#description-value").prop('disabled', !$(this).prop('checked'));
  });

  function show_feature(f) {
    $("#modify a").html(f+1);
    var properties=features[f].properties;
    for (var prop in fields) {
      var val=String(properties[prop]);
      values[prop].val(val).attr('title', val);
    }
  }

  function show_fields() {
    for (var prop in fields) {
      if (fields[prop]) continue;
      // Special fields have non-editable field names.
      var special = /^(GeoJSON_cl(one)?|_id|_rev|_deleted)$/.test(prop);
      var row=$("<span>");
      // render field: value input pair
      var checkbox=$('<input type="checkbox" name="include" checked>').prop('disabled',special);
      var field=$('<input type="text" name="field">').val(prop);
      if (special) field=$('<b>').addClass('special').html(prop).prop('value',prop);
      // Also interpret 'GeoJSON_cl' as GeoJSON_clone automatically.
      // Field names in shape files are constrained to 10 characters,
      // so this is how it will be rendered in most cases.
      if (prop==="GeoJSON_cl") field.prop('value', "GeoJSON_clone");
      var value=$('<input type="text" name="value">').prop('disabled',special);
      values[prop]=value;
      fields[prop]=field;
      row.append(checkbox, field, ': ', value, '<br>');
      $("#modify div").append(row);
      if (special) continue;
      // write new value to displayed feature
      value.change(prop, function(e) {
        var v=$(this).val();
        try {
          v=JSON.parse(v);
          $(this).val(String(v));
        } catch(err) {}
        features[$("#modify a").html()-1].properties[e.data]=v;
      });
      // disable input fields on row if unchecked
      checkbox.change(row, function(e) {
        e.data.find(":text").prop('disabled', !$(this).prop('checked'));
      });
    }
    show_feature(0);
    $("#modify").show();
  }

  function load_features(data, filetype) {
    show_geometry(-1);
    try {
      if (filetype==="geojson") {
        var GeoJSON;
        // reformat JSON.parse error merrages
        try { GeoJSON=JSON.parse(data); }
        catch (err) { throw{message:"JSON.parse: "+err.message}; }
        if (GeoJSON.type==="FeatureCollection") features=GeoJSON.features;
        else if (GeoJSON.type==="Feature") features=[GeoJSON];
        else throw{message:"Unknown or useless GeoJSON type: "+GeoJSON.type};
        if (!GeoJSON.crs) throw{message:"No top-level CRS defined"};
        for (var f=0;f<features.length;f++)
          features[f].geometry.crs=GeoJSON.crs;
      } else if (filetype==="xml") {
        // divide xml recursively into <Tag>..</Tag> objects
        var tables=function parse(xml, tags) {
          if (typeof tags==="object") {
            if (!tags.length) return xml;
            var tag=tags[0];
            var elements=parse(xml, tag);
            for (var i=0;i<elements.length;i++)
              elements[i].xml=parse(elements[i].xml, tags.slice(1));
            return elements;
          }
          var elements=[], tag=tags, m;
          do {
            // match opening <Tag> or singular <Tag/>
            if (!(m=xml.match('<\\s*'+tag+'(/?>|\\s[^>]*>)')))
              continue;
            // parse tag attributes
            var attribs=m[0].match(/[\w:]+="[^"]*"/g);
            var element={};
            while (attribs && attribs.length) {
              var attrib=attribs.pop().match(/([\w:]+)="([^"]*)"/);
              element[attrib[1]]=attrib[2];
            }
            if (m[0].search('/>$')===-1) {
              // strip matched tag from xml
              xml=xml.substring(m.index+m[0].length);
              // match closing </Tag>
              if (!(m=xml.match('</\\s*'+tag+'\\s*>')))
                throw{message:"XML.parse: Missing </"+tag+">"};
              // add xml between <Tag>..</Tag>
              element.xml=xml.substring(0,m.index);
            // add empty xml if <Tag/> is singular
            } else element.xml="";
            elements.push(element);
            // strip processed xml and continue
            xml=xml.substring(m.index+m[0].length);
          } while (m);
          return elements;
        }(data, ["Table","Row","Cell","Data"]);
        features=[];
        while (tables.length) {
          var rows=tables.shift().xml;
          // insert empty xml if ss:Index is set
          function normalize(xml) {
            for (var i=0;i<xml.length;i++)
              while ( i+1 < (xml[i]['ss:Index'] || 0) )
                xml.splice(i++, 0, {xml:[]});
            return xml;
          }
          var columns=normalize(rows.shift().xml);
          while (rows.length) {
            var row=rows.shift().xml;
            // LibreOffice sometimes adds a lot of empty rows to
            // the end of the file. We can safely ignore those.
            if (row.length===1 && !row[0].xml.length) continue;
            row=normalize(row);
            var properties={};
            for (var c=0;c<row.length;c++) {
              if (!columns[c].xml.length) continue;
              var data=row[c].xml[0] || {xml:""};
              if (data['ss:Type']==="String") data.xml=data.xml.replace(/&amp;/g,'&')
                                                               .replace(/&lt;/g,'<')
                                                               .replace(/&gt;/g,'>');
              if (data['ss:Type']==="Number") data.xml=parseFloat(data.xml);
              if (data['ss:Type']==="Boolean") data.xml=(data.xml==="1");
              if (data['ss:Type']==="DateTime") data.xml=data.xml.replace(/-/g,'/')
                                                                 .replace(/T.*/,'');
              properties[columns[c].xml[0].xml]=data.xml;
            }
            features.push({properties:properties});
          }
        }
      } else throw{message:"Unknown extension: ."+filetype};
    } catch(err) {
      $("#upload b").html(err.message+"<br>");
      return;
    }
    fields={};
    values={};
    var doc_ids=[];
    for (var f=0;f<features.length;f++) {
      var properties=features[f].properties;
      if (properties._id) doc_ids.push(properties._id);
      for (var prop in properties)
        fields[prop]=false;
    }
    submit.prop('disabled', false);
    $("#modify div").html('');
    show_fields();
    uploaded_docs={};
    // store existing documents
    $.post('/'+db+"/_all_docs?include_docs=true", JSON.stringify({keys:doc_ids}), function(data) {
      data=JSON.parse(data);
      while (data.rows.length) {
        var row=data.rows.pop();
        uploaded_docs[row.id]=row.doc;
      }
      relay_geometries();
    });
  }

  // Check if geometry is about to be dropped in the
  // next upload, and fix related documents accordingly.
  function relay_geometries() {
    var doc_ids=[], relays={};
    for (var f=0;f<features.length;f++) {
      var relayed=features[f].properties;
      var doc=uploaded_docs[relayed._id];
      // Map document id to its feature.
      if (doc) relays[relayed._id]=features[f];
      // Nothing to be done if the document wasn't in the
      // database before or doesn't have its own geometry.
      if (!doc || doc.GeoJSON_clone) continue;
      // Something should be done if the document will be removed.
      if (relayed._deleted!==true) {
        // Nothing to be done if the document will keep its geometry.
        if (!relayed.GeoJSON_clone) continue;
        if (relayed.GeoJSON_clone===doc._id) continue;
      }
      doc_ids.push(relayed._id);
    }
    $.getJSON('_view/geojson-doc?keys='+JSON.stringify(doc_ids), function(data) {
      var doc_ids=[], rows=data.rows, row;
      for (var r=0; row=rows[r]; r++)
        // Splice rows that reference the document itself.
        if (row.key===row.id) rows.splice(r--, 1);
        // Fetch missing documents.
        else if (!uploaded_docs[row.id]) {
          uploaded_docs[row.id]=true;
          doc_ids.push(row.id);
        }
      // Nothing to be done of no other documents are involved.
      if (rows.length) $.getJSON('/'+db+"/_all_docs", {
        keys:JSON.stringify(doc_ids), include_docs:true
      }, function(data) {
        while ( row=data.rows.pop() ) {
          uploaded_docs[row.id]=row.doc;
          features.push( relays[row.id]={
            unchanged:true,
            properties:{
              _id:row.doc._id, _rev:row.doc._rev,
              GeoJSON_clone:row.doc.GeoJSON_clone
            }
          });
        }
        for ( var r=rows.length; row=rows[--r]; rows.splice(r) ) {
          var key=row.key, acceptor=undefined;
          var relayed=relays[key].properties;
          do {
            var relay=relays[row.id].properties;
            // Ignore features that are staged for deletion anyway.
            if (relay._deleted) rows.splice(r,1);
            // Pocket current feature if it links to
            // nothing else than the deleted geometry.
            else if ( !acceptor && relayed._deleted===true &&
                      relay.GeoJSON_clone.match(/[^\s,;&]+/g).length===1 )
              acceptor=relays[rows.splice(r,1)[0].id];
            row=rows[r-1] || {};
          } while (row.key===key && r--)
          if (!acceptor && relayed._deleted===true) {
            // If the deleted document is not pointed at exclusively, we just
            // unset its type, thus hiding it from most of the indexed views.
            // Its geometry is still seen in _view/bbox and _view/geojson.
            delete relayed._deleted;
            relayed.type=null;
            continue;
          }
          if (acceptor && relayed._deleted===true) {
            // If we have an exclusive pointer to the deleted document,
            // then move its geometry into the pointing document,
            acceptor.geometry=uploaded_docs[relayed._id].GeoJSON;
            // tell the submit handler that the geometry must be updated,
            acceptor.properties.GeoJSON_clone=null;
            // and point all other features to the new doc id.
            relayed.GeoJSON_clone=acceptor.properties._id;
            delete acceptor.unchanged;
          }
          while ( r!==rows.length ) {
            row=rows.pop();
            var relay=relays[row.id].properties;
            relay.GeoJSON_clone = relay.GeoJSON_clone.replace(
              RegExp('\\b'+relayed._id+'\\b'),
              relayed.GeoJSON_clone
            );
            delete relays[row.id].unchanged;
          }
          // Add special field GeoJSON_clone and update #modify div
          if (fields.GeoJSON_clone) continue;
          fields.GeoJSON_clone=false;
          show_fields();
        }
        // Unstage unchanged documents from upload.
        for (var f=0;f<features.length;f++) {
          if (!features[f].unchanged) continue;
          delete uploaded_docs[features[f].properties._id];
          features.splice(f--, 1);
        }
      });
    });
  }

  $("#upload :file").change(function(e) {
    $("#modify").hide();
    $("#reduce [name=show]").show();
    $("#reduce span").hide();
    $("#reduce").hide();
    $("#upload b").html("");
    $("#results").html();
    submit.prop('disabled', true).show();
    revert.hide();
    var reader=new FileReader();
    // get file type and be flexible about extensions
    var filetype=e.target.files[0].name.match(/[^.]*$/)[0];
    if (/^(geojson|json)$/i.test(filetype)) filetype="geojson";
    if (/^xml$/i.test(filetype)) filetype="xml";
    reader.onload=function(evt) {
      load_features(evt.target.result, filetype);
    };
    reader.readAsText(e.target.files[0]);
  });

  $("#upload :text").change(function() {
    $("#modify").hide();
    $("#reduce [name=show]").show();
    $("#reduce span").hide();
    $("#reduce").hide();
    $("#upload b").html("");
    $("#results").html();
    submit.prop('disabled', true).show();
    revert.hide();
    $.ajax({
      dataType:"text",
      url:$("#upload :text").val(),
      error:function(jqXHR, text, error) {
        $("#upload b").append(text+' '+error, "<br>");
      },
      success:function(data, text, jqXHR) {
        var filetype=jqXHR.getResponseHeader('Content-type');
        if (filetype==="text/xml") filetype="xml";
        else filetype="geojson";
        load_features(data, filetype);
      }
    });
  });

  $("#modify").submit(function(e) {e.preventDefault();});

  // check/uncheck all
  $("#modify [name=all]").change(function() {
    $("#modify :checkbox:enabled").prop('checked', $(this).prop('checked'));
    $("#modify [name=include]").change();
  });

  $("#modify [name=prev]").click(function() {
    var f=$("#modify a").html();
    if (--f<1) f=features.length;
    show_feature(f-1);
  });

  $("#modify [name=next]").click(function() {
    var f=$("#modify a").html();
    if (++f>features.length) f=1;
    show_feature(f-1);
  });

  // compile features into document array
  $("#upload").submit(function(e) {
    var type=$("#modify [name=type]").val();
    var time=$("#modify [name=time]").val();
    var docs=[];
    for (var f=0;f<features.length;f++) {
      var feature=features[f];
      var doc=uploaded_docs[feature.properties._id] || {};
      // detach doc from uploaded_docs
      doc=JSON.parse(JSON.stringify(doc));
      // set doc-type and time
      doc.type=type || doc.type || undefined;
      doc.time=time || doc.time || undefined;
      // save document description as doc[doc.type]
      if ($("#description-include").prop('checked') && doc.type)
        doc[doc.type]=$("#description-value").val() || doc[doc.type] || undefined;
      // write properties with adjusted labels
      for (var prop in feature.properties) {
        if (fields[prop].prop('disabled')) continue;
        if (fields[prop].val()=="") continue;
        var obj=doc, field;
        var components=path.decode(fields[prop].val());
        // build nested object from field components
        while ((field=components.shift()) && components.length)
          obj=obj[field]||(obj[field]={});
        // remove undefined fields
        obj[field]=feature.properties[prop];
      }
      // clean up redundant JSON recursively
      (function empty(obj) {
        // There is no semantic difference between
        // these values and a missing property.
        if ([null,"","null","undefined"].indexOf(obj)!==-1)
          return true;
        if (typeof obj!=="object") return false;
        var result=true;
        // Arrays need to be spliced.
        if (Array.isArray(obj)) {
          for (var p=0; p<obj.length; p++)
            if (empty(obj[p])) obj.splice(p--, 1);
            else result=false;
          return result;
        }
        for (var p in obj)
          if (p==="GeoJSON" && obj===doc || !empty(obj[p])) result=false;
          else delete obj[p];
        return result;
      })(doc);
      // Use either the newly defined GeoJSON_clone or the previous
      // one. Update the geometry itself only if none is referenced.
      if (!doc.GeoJSON_clone && feature.geometry)
        doc.GeoJSON=feature.geometry;
      // Remove GeoJSON_clone if it references itself.
      if (doc.GeoJSON_clone===doc._id) delete doc.GeoJSON_clone;
      else if (doc.GeoJSON_clone) delete doc.GeoJSON;
      docs.push(doc);
    }
    $.couch.db(db).bulkSave( {docs:docs}, { success:function(data) {
      $("#modify").hide();
      $("#reduce").show();
      map = map || new Maps.Map($('#map')[0], {
        zoom: 17, mapTypeId: Maps.MapTypeId.SATELLITE,
        center: new LatLng(50.83730534254573, 13.938310197234163)
      });
      submit.hide();
      revert.show();
      var results=[];
      // Get IDs of new documents and update revisions if no error occured.
      while (data.length) {
        var item=data.pop();
        var result=item.ok && "ok" || item.error+" ("+item.reason+")";
        results[result] = results[result] + 1 || 1;
        var uploaded_doc = uploaded_docs[item.id] || {};
        features[data.length].id = item.id;
        features[data.length].rev =
                uploaded_doc._rev = item.rev || uploaded_doc._rev;
      }
      for (var result in results)
        results.push(results[result]+" "+result);
      $("#results").html(results.join(", "));
    }});
    e.preventDefault();
  });

  revert.click(function() {
    var docs=[];
    // delete or upload previous revision
    for (var f=0;f<features.length;f++) {
      var feature=features[f];
      docs.push( uploaded_docs[feature.id] || {
        _deleted:true,
        _id:feature.id,
        _rev:feature.rev
      });
    }
    relay_geometries();
    $.couch.db(db).bulkSave( {docs:docs}, { success:function(data) {
      submit.show();
      revert.hide();
      show_fields();
      $("#reduce").hide();
      while (data.length) {
        var item=data.pop();
        if (!uploaded_docs[item.id] || item.error) continue;
        // update rev in case we want to upload again
        features[data.length].properties._rev=item.rev;
      }
    }});
  });

  function show_geometry(f) {
    // remove previous shapes from map canvas
    var feature=features[$("#show-suggestions a").html()-1];
    if (feature) {
      if (feature.shape) feature.shape.setMap();
      delete feature.shape;
      for (var id in feature.items) {
        if (feature.items[id].hidden) continue;
        feature.items[id].shape.setMap();
        delete feature.items[id].shape;
      }
    }
    $("#show-suggestions a").html(f+1);
    if (!(feature=features[f])) return;
    var keys=[];
    if (!feature.items[feature.id]) keys.push([feature.id, 0]);
    for (var id in feature.items) keys.push([id, 0]);
    $("#reduce :button").prop('disabled', true);
    $.post("_view/geojson", JSON.stringify({keys:keys}), function(data) {
      $("#reduce :button").prop('disabled', false);
      data=JSON.parse(data);
      function select_me() {
        shape.setOptions({strokeColor:"#000000"});
        this.setOptions({strokeColor:"#FF0000", zIndex:-new Date().getTime()});
        shape=this;
        var a=$("#clone-from a");
        a.prop('href',"/_utils/document.html?"+db+'/'+this.GeoJSON_clone);
        if (this.GeoJSON_clone) $.getJSON('/'+db+'/'+this.GeoJSON_clone, function(doc) {
          a.html(doc[doc.type] || doc);
          if (doc.time) a.append(' ('+doc.time+')');
        });
        var spans={ true: $("#clone-from"), false: $("#create-new") };
        spans[!this.GeoJSON_clone].hide();
        spans[!!this.GeoJSON_clone].show();
        for (var f=0;f<features.length;f++) {
          if (!features[f].items || features[f]===feature) continue;
          // Update reference count of each feature; A feature is only allowed
          // for geometry clone selection if no other feature references it.
          features[f].cloned += (this.GeoJSON_clone===features[f].id);
          features[f].cloned -= (feature.properties.GeoJSON_clone===features[f].id);
          // Hide suggestions that already link to other geometries.
          (features[f].items[feature.id] || {}).hidden
            = this.GeoJSON_clone && this.GeoJSON_clone!==feature.id;
        }
        feature.properties.GeoJSON_clone=this.GeoJSON_clone;
      }
      while (data.rows.length) {
        var row=data.rows.pop();
        var GeoJSON_clone=feature.items[row.key[0]] && row.key[0];
        if (GeoJSON_clone && feature.items[GeoJSON_clone].hidden)
          continue;
        var GeoJSON=row.value.GeoJSON;
        var shape=create_shape(GeoJSON.type, expand_options({
          fillColor:GeoJSON_clone!==feature.id?"#0000FF":"#00FF00",
          map:map, coordinates: GeoJSON.coordinates, draggable: true
        }));
        shape.GeoJSON_clone=GeoJSON_clone;
        shape.addListener('click', select_me);
        (feature.items[row.key[0]] || feature).shape=shape;
      }
      map.setCenter(new LatLng((feature.bbox[3]+feature.bbox[1])/2.0+offset[1],
                               (feature.bbox[2]+feature.bbox[0])/2.0+offset[0]));
      shape = (feature.items[feature.properties.GeoJSON_clone] || feature).shape
      select_me.apply(shape);
    });
  }

  // skip to next/previous document with similar geometry
  $("#reduce [name=next]").click(function() {
    var f=$("#show-suggestions a").html()-1;
    do f=(f+1)%features.length;
    while (!features[f].items || features[f].cloned)
    show_geometry(f);
  });

  $("#reduce [name=prev]").click(function() {
    var f=$("#show-suggestions a").html()-1;
    do f=(f+features.length-1)%features.length;
    while (!features[f].items || features[f].cloned)
    show_geometry(f);
  });

  // query for similar geometry
  $("#reduce [name=show]").click(function() {
    $(this).hide();
    $("#show-suggestions").show();
    $("#show-suggestions :button").prop('disabled', true);
    // Add GeoJSON_clone field indicator.
    fields.GeoJSON_clone = fields.GeoJSON_clone || false;
    var keys=[];
    for (var f=0;f<features.length;f++)
      keys.push(features[f].properties.GeoJSON_clone || features[f].id)
    $.post("_list/bbox-filter/bbox", JSON.stringify({keys:keys}), function(data) {
      for (var f=0;f<features.length;f++) {
        if (!data[keys[f]]) continue;
        var feature=features[f];
        feature.bbox=data[keys[f]].GeoJSON.bbox;
        var options=encodeURIComponent(JSON.stringify({
          bbox:feature.bbox,
          similarity:0.0001
        }));
        var found_geometry=function() {
          $("#show-suggestions :button").prop('disabled', false);
          $("#reduce [name=next]").click();
          found_geometry=function() {};
        }
        $.getJSON("_list/bbox-filter/bbox?options="+options, function(id, feature) {
          return function(data) {
            // remove from items if geometry is new
            if (id===feature.id && !feature.properties.GeoJSON_clone)
              delete data[id];
            // This leaves doc.items undefined if data is
            // empty or consists only of the cloned geometry.
            for (var id2 in data) {
              if (id2===id) continue;
              feature.items=data;
              feature.cloned=0;
              found_geometry();
              return;
            }
          };
        }(keys[f], feature));
      }
    });
  });

});
</script>

<style>
  label, span.nowrap {white-space:nowrap}
  .special {display:inline-block; min-width:7em}
</style>

  </head>
  <body style="height:100%">

  <iframe src="login_bar.htm" style="width:100%; height:1.6em; border:0;"></iframe>

  <h1> XML/GeoJSON-Upload </h1>
  <form id="upload">
    <input type="file">
    <label>URL: <input type="text" title="Keine fremden Domains!!!"></label>
    <input type="submit" value="Los!" disabled>
    <input type="button" value="Rückgängig" name="revert" style="display:none"><br>
    <b></b>
  </form>
  <b id="results"></b>
  <form id="modify" style="display:none">
    <label>Datensatz-Typ: <input type="text" name="type" size="10" value=""></label>
    <label>Zeitraum: <input type="text" name="time" size="15"></label><br>
    <label><input type="checkbox" name="all" checked>Alle Felder auswählen</label>
    <span class="nowrap">
      <input type="button" name="prev" value="<"> Datensatz <a>1</a>
      <input type="button" name="next" value=">"></span><br>
    <label>
      <input id="description-include" type="checkbox" checked>
      <b id="description-field">&lt;Datensatz-Typ&gt;</b><b>:</b></label>
    <input id="description-value" type="text">
    <div></div>
    <label><input type="checkbox" name="all" checked>Alle Felder auswählen</label>
    <span class="nowrap">
      <input type="button" name="prev" value="<"> Datensatz <a>1</a>
      <input type="button" name="next" value=">"></span>
  </form>
  <form id="reduce" style="display:none;height:50%">
    <input type="button" name="show" value="Ähnliche Geometrien suchen">
    <span id="show-suggestions" style="display:none" class="nowrap">
      Ähnliche Geometrien für
      <input type="button" name="prev" value="<"> Datensatz <a>0</a>
      <input type="button" name="next" value=">"></span>
    <div id="map" style="height:100%"></div>
    <span id="create-new" style="display:none">Eigene/Neue Geometrie verwenden.</span>
    <span id="clone-from" style="display:none">Geometrie
      von Datensatz <a target="_blank"></a> verwenden.</span>
  </form>
  </body>
</html>
