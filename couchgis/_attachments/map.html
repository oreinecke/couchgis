<!DOCTYPE html>

<html lang="de" style="height:125%">
  <head>
    <title>Karte</title>
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8">
    <link href="css/jquery-ui-1.10.4.custom.css" rel="stylesheet">
    <script src="script/jquery-1.11.1.min.js"></script>
    <script src="script/jquery-ui-1.10.4.custom.js"></script>
    <script src="script/require.js"></script>
    <script type="text/javascript" src="https://maps.googleapis.com/maps/api/js?v=3.16&sensor=false"></script>
    <script src="script/google.maps.js"></script>
    <script src="script/fillColors.js"></script>

<script type="text/javascript">
$(document).ready(function() {

  var map = new Maps.Map($('#map')[0], {
    zoom: 12,
    mapTypeId: Maps.MapTypeId.SATELLITE,
    center: new LatLng(50.83730534254573, 13.938310197234163)
  });

  var path=require('views/lib/path');
  var ranges=require('views/lib/ranges');
  var indexes=require('views/lib/indexes');

  // call _list/bbox-filter/<view> with some useful options
  function list(list, options, success) {
    var data={keys:options.keys, GeoJSON:options.GeoJSON};
    delete options.keys;
    delete options.GeoJSON;
    list+="?options="+encodeURIComponent(JSON.stringify(options));
    $.ajax("_list/"+list, {
      type:"POST",
      dataType:"json",
      data:JSON.stringify(data),
      success:success,
      error:call.that_last_one
    });
  }
  // ok this also looks retarded but it keeps my stuff in one place at least
  list.parts=window.location.pathname.split('/');
  list.db=list.parts[1];
  list.app=list.parts[2]+'/'+list.parts[3];
  delete list.parts;

  // It is very likely that the oftentimes inexperienced user clicks and
  // scrolls the map like an ape (on adderall). Then, event handler callbacks
  // will be fired all over the place and the interface probably won't react
  // anymore. It should be smarter than that; It should wait a couple of
  // seconds, then wait for the last ajax to complete, then do the next thing
  // that needs to be done.
  var call={
    now:null, next:null,
    this_one_next:function(what) {
      // We might as well do the closure here, because this
      // is used only for event handler registration anyway.
      return function() {
        if (call.now!==null) call.next=what;
        else (call.now=what)();
      }
    },
    that_last_one:function() {
      window.setTimeout(function() {
        call.now=call.next;
        call.next=null;
        if (call.now!==null) call.now();
      }, 500);
    },
    no_one:function() {
      call.now=null;
      call.next=null;
    }
  };
  // All items that are displayed on the map are in here as "id":{etc.}.
  var items={};
  // This contains an ordered list of ALL GeoJSON keys.
  var keys=[];
  // This contains a cascading viewport array,
  // initialized to one default element.
  var viewports=[{
    bbox: [-Infinity,-Infinity,Infinity,Infinity],
    prefix: [], // (limited) items returned by this viewport
    position: 0 // index from which to append remaining keys
  }];
  // Same as viewports for content-based filters.
  var filters=[{ types:[], time:"", documents:[], union:[] }];

  // query for GeoJSON and full documents
  function update_geometry() {
    var geometries=[], documents=[];
    for (var id in items) {
      var item=items[id];
      if (!item.keep_shape)
        geometries.push(item.keys[0]);
      if (!item.keep_documents)
        documents=documents.concat(item.keys.slice(1));
    }
    if (geometries.reverse().length + documents.reverse().length === 0)
      return call.that_last_one();
    var successful=false;
    function ajax() {
      $.ajax("_view/geojson", {
        type:"POST",
        data:'{"keys":'+JSON.stringify(documents.concat(geometries))+'}',
        dataType:"json",
        success:success,
        complete:function() {
          // Sadly, this seems to be the only way to catch
          // CouchDB's internal server error or whatever this is.
          if (!successful)
            window.setTimeout(ajax, 50);
        }
      });
    }
    ajax();
    // Even more sad: I need to add this timer
    // because Chrome does not call 'complete'.
    window.setTimeout(function() { if (!successful) ajax(); }, 3000);
    function success(data) {
      successful=true;
      // timeout is 5ms or instantaneous
      var timeout = 5 * $("#settings [name=delayed]").prop('checked');
      var headers=$("#table th");
      (function update_one_geometry() {
        while (data.rows.length) {
          var row=data.rows.pop();
          var item=items[row.key[0]];
          if (row.value.doc) {
            data.rows.push(row);
            var tr=item.tr;
            tr.html('');
            // append <th>'s from headers as <td>'s and copy class name
            headers.each(function() { tr.append($("<td>")); });
            var columns=tr.find("td");
            var fillColor=null;
            for (var d=1;d<item.keys.length;d++) {
              // Group docs with identical GIS into one li.
              var doc=data.rows.pop().value.doc;
              if (!fillColor) fillColor=fillColors[doc.type];
              headers.each(function(i) {
                var th=$(this);
                var td=$(columns[i]);
                var cl=th.prop('class');
                if (cl==="title-time" || cl==="title") {
                  // Link to Futon for the lack of a better interface
                  // and set link text to a useful item explanation.
                  var a=$("<a>").attr({
                    href:"/_utils/document.html?"+list.db+'/'+doc._id, target:"_blank"
                  }).text( doc[doc.type]||doc.type );
                  if (cl==="title-time" && doc.time)
                    a.append(' ('+doc.time+')');
                  td.append(a, '<br>');
                // evaluate columns
                } else if (cl==="field") {
                  var fields=path.decode(th.val()), value=doc;
                  while (fields.length && value!=null) value=value[fields.shift()];
                  var span=$('<span>').text(value);
                  // Copy cell content and field name to #filter.
                  span.addClass('field').click({
                    field:th.text(), value:span.text().replace(/[.*+?^=!:${}()|\[\]\/\\]/g, "\\$&")
                  }, update_geometry.create_filter);
                  td.append(span, '<br>');
                }
                if (cl!=="geometry") return;
                // Set-up link to geometry: I use a very bold bullet point.
                td.html($("#table thead .geometry span").html()).addClass("geometry");
                td.click(item, update_geometry.highlight_shape);
              });
            }
            // If colored black, (Multi)LineStrings are difficult to spot on the map.
            if (item.shape instanceof Maps.Polygon || item.shape instanceof MultiPolygon)
              item.shape.setOptions({fillColor:fillColor});
            else item.shape.setOptions({strokeColor:fillColor});
            item.keep_documents=true;
            continue;
          }
          var options=expand_options({ coordinates:row.value.GeoJSON.coordinates, map:map});
          if (item.shape==null) {
            item.shape=create_shape(row.value.GeoJSON.type, options);
            item.shape.addListener('click', update_geometry.highlight_row);
          } else item.shape.setOptions(options);
          if (!timeout) continue
          window.setTimeout(update_one_geometry, timeout);
          return;
        }
        call.that_last_one();
      })();
    }
  }

  update_geometry.highlight_row=function() {
    this.setOptions({zIndex:-new Date().getTime()});
    for (var id in items) {
      var item=items[id];
      if (item.shape!==this) continue;
      // IE-10.0 loses this <a>'s focus because the map was clicked
      // once before. It works just fine if we delay it by 1ms.
      window.setTimeout(function() {
        $("#table tbody").prepend(item.tr);
        item.tr.find('a').first().focus();
      }, 1);
      return;
    }
  };

  update_geometry.highlight_shape=function(e) {
    var item=e.data;
    var bbox=item.GeoJSON.bbox;
    map.setCenter(new LatLng( (bbox[3]+bbox[1])/2.0, (bbox[2]+bbox[0])/2.0 ));
    item.shape.setOptions({strokeColor:"#FF0000", zIndex:new Date().getTime()});
    // Center map to the shape and highlight it.
    $("#table tbody").prepend(item.tr);
    e.preventDefault();
  };

  update_geometry.create_filter=function(e) {
    $("#filter [name=field]").val(e.data.field);
    $("#filter [name=content]").val(e.data.value).keypress();
  };

  // diff-updates items inside viewport
  function update_items(error) {
    var NE=map.getBounds().getNorthEast();
    var SW=map.getBounds().getSouthWest();
    var options={
      limit:parseFloat($("#settings [name=limit]").val()),
      error:(error===undefined ? (NE.lat()-SW.lat())/100 : error),
      bbox:[ SW.lng(), SW.lat(), NE.lng(), NE.lat() ],
    };
    var vp;
    // pop viewports until one is found that surrounds bbox
    do vp=viewports.pop();
    while (options.bbox[0]<vp.bbox[0]||options.bbox[1]<vp.bbox[1]||
           options.bbox[2]>vp.bbox[2]||options.bbox[3]>vp.bbox[3]);
    // the last viewport is valid, so it needs to be re-stacked
    viewports.push(vp);
    // abort if we already see less items than requested
    if (vp.populated) {
      call.that_last_one();
      return;
    }
    // ignore items that were already dropped by previous viewport
    options.keys=vp.prefix.concat(keys.slice(vp.position));
    var table = $("#table tbody");
    list("bbox-filter/bbox", options, function(data) {
      var position=0;
      // lists items to be removed as {id:null}
      var old_items={};
      for (var id in items) old_items[id]=null;
      // prepare new viewport
      var new_vp={ bbox:options.bbox, prefix:[] };
      var documents=filters[filters.length-1].documents;
      // I need the last prop of data after the loop again. And
      // yes, I know it looks silly and it makes no difference.
      var id; for (id in data) {
        new_vp.prefix.push(id);
        if (items[id]) {
          delete old_items[id];
          var KEYS=items[id].keys;
          items[id].keep_shape=(KEYS[0][1]===data[id].GeoJSON.error);
          KEYS[0][1]=data[id].GeoJSON.error;
          continue;
        }
        items[id]=data[id];
        var tr=$("<tr>");
        table.append(tr);
        items[id].tr=tr;
        // fetch GeoJSON of specified detail level
        var KEYS=[[id, data[id].GeoJSON.error]];
        // skip to matching document id
        while (documents[position][0]!==id)
          position=(position+1)%documents.length;
        // add all associated documents
        while (position<documents.length && documents[position][0]===id)
          KEYS.push(documents[position++]);
        items[id].keys=KEYS;
      }
      if (new_vp.prefix.length<options.limit) {
        // note that we've retrieved all items with this viewport
        new_vp.populated=true;
        // set full detail level automatically in this case
        if (error!==0) for (var id in data) {
          // keep items that are already displayed
          items[id].keep_shape=items[id].shape && (items[id].keys[0][1]===0);
          items[id].keys[0][1]=0;
        }
      }
      // If the query returned less than the required items, then these must
      // be the only items within the viewport. In this case the index may be
      // set to the end of the list, and no keys are appended.
      if (new_vp.prefix.length<options.limit) new_vp.position=keys.length;
      // In any other case it is safe to assume that any key before the
      // last one is either outside the viewport or already in prefix.
      else new_vp.position=keys.indexOf(id)+1;
      // Add new_vp to viewport stack, but only if it is indeed more restrictive.
      if (new_vp.position>vp.position || new_vp.prefix.length<vp.prefix.length)
        viewports.push(new_vp);
      // remove out-of-viewport shapes and links
      for (var id in old_items) {
        items[id].shape.setMap();
        items[id].tr.remove();
        delete items[id];
      }
      // Fetch changed geometries in 50 ms.
      window.setTimeout(update_geometry, 50);
    });
  }

  // Applies new filter to document list; new_filter must be an object
  // denoting the filter type by its first member. It is then either
  // i) attached at the end of the filter queue
  // ii) inserted in the middle and merged with filters following it
  // iii) nothing of the above if an identical filter is already used.
  function filter_documents(new_filter) {
    var commands=filter_documents.commands;
    if (!commands) {
      // Set up a new command stack if none is in place yet.
      commands=Array.prototype.slice.apply(arguments, [1]);
      filter_documents.commands=commands;
    } else if (arguments[0]!==commands) {
      // If filters are already processed parallel to
      // this, push new filters to the command stack.
      Array.prototype.push.apply(commands, arguments);
      return;
      // filter_documents(filter_documents.commands) is
      // employed below to recurse to the next filter.
    } else new_filter=commands.shift();
    // If the command stack is depleted, reset
    // viewports, update geometries and etc.
    if (!new_filter) {
      var documents=filters[filters.length-1].documents;
      keys.splice(0);
      viewports.splice(1);
      for (var d=0, id=null; d<documents.length; d++) {
        if (id===documents[d][0]) continue;
        id=documents[d][0];
        keys.push(id);
        if (!items[id]) continue;
        var old_keys=items[id].keys;
        old_keys.splice(1);
        while (d<documents.length && id===documents[d][0])
          old_keys.push(documents[d++]);
        // update document list in the next _view/geojson
        items[id].keep_documents=false;
        // the nested loop results in an off-by-one document index
        d--;
      }
//    window.setTimeout(function() { Maps.event.trigger(map, 'bounds_changed'); },50);
      delete filter_documents.commands;
      Maps.event.trigger(map, 'bounds_changed');
      return;
    }
    // Aquire first property as name of new_filter.
    var filter_name=function() {for (var prop in new_filter) return prop;}();
    // In any case, we can use the full, non-filtered document list.
    var documents=filters[0].documents;
    // Remind me if we already have an identical filter in place.
    var equal_filter=false;
    var position=0;
    // Check what document list to reuse: As soon as a conflicting (that is
    // non-containing) filter is found, this one and every filter following it
    // need to be re-evaluated.
    while ( position<filters.length && function(filter) {
      // In this part we determine for each filter type if it
      // a) is more restrictive than an already applied filter, and
      // b) happens to be identical to said filter.
      // I have written this part using an anonymous function because it is
      // most concise and every attempt to do this without resulted in
      // additional clutter. Also I expect filters.length not to exceed 20.
      if (new_filter.redo===filter) return false;
      if (filter[filter_name]==null) return true;
      if (filter_name==="union") {
        filter.union=new_filter.union;
        // Tag document selection to bypass _list/tabulate.
        for (var d=0;d<filter.union.length;d++)
          filter.union[d].keep_me=true;
        if (filter.union.length) return true;
        // Remove the tag from each document if new_filter.union is empty.
        // Here I take advantage over the circumstance that, by the poor design
        // of my interface, new_filter.union is only shrinking to an empty set.
        for (var d=0;d<documents.length;d++)
          delete documents[d].keep_me;
        // Here I cause the remaining filters to collapse into filters[1],
        // because I want to leave the top-level filter untouched.
        position++;
        return false;
      }
      if (filter_name==="spatial")
        return (new_filter.spatial);
      if (filter_name==="time") {
        var contains=(ranges.contains(filter.time, new_filter.time));
        if (contains) equal_filter=(ranges.contains(new_filter.time, filter.time));
        return contains;
      }
      if (filter_name==="types") {
        var contains=(new_filter.types.length<=filter.types.length);
        for (var t=0; contains && t<new_filter.types.length; t++)
          contains &= (filter.types.indexOf(new_filter.types[t])!==-1);
        if (contains) equal_filter=(new_filter.types.length===filter.types.length);
        return contains;
      }
      if (filter_name==="cuts") {
        var cut=new_filter.cuts[0];
        if (!cut.remove_me) return true;
        var index=filter.cuts.indexOf(cut);
        if (index===-1) return true;
        filter.cuts.splice(index,1);
        delete new_filter.cuts;
        return false;
      }
    }(filters[position]) )
      // If the last filter was compatible, we can use its document list.
      documents=filters[position++].documents;
    filters.push(new_filter);
    // Divert spatial filters to the request chain below.
    if (new_filter.spatial) {
      var passed=new_filter.passed || function(keys) {
        var result={};
        for (var k=0;k<keys.length;k++)
          result[keys[k]]=true;
        new_filter.data='{"keys":[["'+keys.join('",0],["')+'",0]]}';
        delete new_filter.keys;
        return result;
      }(new_filter.keys);
      $.post("_view/geojson", new_filter.data, function(data) {
        var GeometryCollection={ type:"GeometryCollection", geometries:[] };
        var bbox=[Infinity,Infinity,-Infinity,-Infinity];
        while (data.rows.length) {
          var GeoJSON=data.rows.pop().value.GeoJSON;
          var bbox2=GeoJSON.bbox;
          bbox[0]=(bbox[0]<bbox2[0]?bbox:bbox2)[0];
          bbox[1]=(bbox[1]<bbox2[1]?bbox:bbox2)[1];
          bbox[2]=(bbox[2]>bbox2[2]?bbox:bbox2)[2];
          bbox[3]=(bbox[3]>bbox2[3]?bbox:bbox2)[3];
          delete GeoJSON.bbox;
          delete GeoJSON.crs;
          delete GeoJSON.error;
          GeometryCollection.geometries.push(GeoJSON);
        }
        var keys=[];
        for (var d=0, id=null; d<documents.length; d++) {
          if (id===documents[d][0]) continue;
          id=documents[d][0];
          if (passed[id]===undefined) keys.push(id);
        }
        var options={keys:keys, bbox:bbox, relation:new_filter.spatial};
        list("bbox-filter/bbox", options, function(data) {
          options.keys=[];
          for (var id in data) options.keys.push([id,0]);
          options.GeoJSON=GeometryCollection;
          delete options.bbox;
          list("bbox-filter/geojson", options, function(data) {
            var new_documents=[];
            while (keys.length) {
              var id=keys.pop();
              passed[id]=id in data;
            }
            for (var d=0, doc; d<documents.length; d++)
              if (passed[(doc=documents[d])[0]])
                new_documents.push(doc);
            new_filter.documents=new_documents;
            new_filter.passed=passed;
            filter_documents(commands);
          });
        });
      }, "json");
      return;
    }
    // Collapse remaining filters into options.
    var options={cuts:[]};
    for (var filter; filter=filters.splice(position,1)[0]; ) {
      if ('time' in filter) options.time=filter.time;
      if ('types' in filter) options.types=filter.types;
      if ('cuts' in filter) options.cuts=options.cuts.concat(filter.cuts);
      // Issue spatial to be applied when the other filters are done.
      if (new_filter.spatial===false) continue;
      if ('spatial' in filter) commands.push(filter);
    }
    // Remove options.cuts array if empty.
    if (!options.cuts.length) delete options.cuts;
    // Remove filter from options if an identical one has already been applied.
    if (equal_filter) delete options[filter_name];
    // Avoid query if all filters have been removed from options.
    if (function() { for (var prop in options) return; return true; }())
      return filter_documents(commands);
    // Pre-filter documents with indexed type and year. This improves
    // response time if it's used for the first or second filter item.
    if ( (options.types || options.time) && position<=2 && !new_filter.redo ) {
      // Obtain simplified [type,year] pairs from
      // _view/type-year matching options' filters.
      $.get("_list/tabulate/type-year", {
        group_level:2, options: JSON.stringify({
          // Fetch filter from options or filters[1], but not from
          // filters[0] because those would only slow the list down.
          types: options.types || filters[1] && filters[1].types,
          time: options.time || filters[1] && filters[1].time
        })
      }, function(keys) {
        // _list/tabulate already returns a valid JSON array of keys, so
        // it just needs to be URIencoded and run by the unreduced view.
        keys=encodeURIComponent(keys);
        $.getJSON("_view/type-year?reduce=false&keys="+keys, function(data) {
          // Hash matching document ids into doc_ids.
          var doc_ids={};
          while (data.rows.length)
            doc_ids[data.rows.pop().id]=true;
          // If only the type and nothing else has been pre-
          // filtered, there is no need to reissue the filter.
          var redo=false;
          for (var prop in options)
             redo |= prop!=="types";
          var new_documents=[];
          for (var d=0;d<documents.length;d++) {
            var doc=documents[d];
            if (doc.keep_me || doc[1] in doc_ids)
              new_documents.push(doc);
            // Tag document to be skipped once next time.
            else doc.skip_me=redo;
          }
          // Issue filter again if other filters were involved,
          if (redo) commands.unshift({redo:options});
          // otherwise set up the new filter and we're done.
          else options.documents=new_documents;
          filters.push(options);
          filter_documents(commands);
        });
      }, "text");
      return;
    }
    options.keys=[];
    for (var d=0;d<documents.length;d++) {
      var doc=documents[d];
      if (!doc.keep_me && !doc.skip_me) options.keys.push(doc);
      delete doc.skip_me;
    }
    list("tabulate/geojson", options, function(data) {
      var new_documents=[];
      var doc_id=data.reverse().pop();
      for (var d=0;d<documents.length;d++) {
        var doc=documents[d];
        if (doc[1]===doc_id) {
          doc_id=data.pop();
          new_documents.push(doc);
        } else if (doc.keep_me)
          new_documents.push(doc);
      }
      options.documents=new_documents;
      delete options.keys;
      filters.push(options);
      filter_documents(commands);
    });
  }

  // Initialize map position and geometry as soon as map has finished loading.
  Maps.event.addListenerOnce(map, 'tilesloaded', function() {
    // set viewport and zoom level
    $.getJSON("_view/dimensions", function(data) {
      var bbox=data.rows[0].value.bbox;
      map.setCenter(new LatLng((bbox[3]+bbox[1])/2.0, (bbox[2]+bbox[0])/2.0));
      // also initialize the time text field
      $("#filter [name=time]").val(ranges.toString(data.rows[0].value.ranges));
    });
    // get list of GeoJSON keys, largest to smallest item
    $.getJSON("_view/dimensions?reduce=false&descending=true&end_key=0", function(data) {
      while (data.rows.length)
        keys.push(data.rows.shift().id);
      // update GeoJSON according to viewport
      // get associated document ids
      $.post("_view/geojson-doc", JSON.stringify({keys:keys}), function(data) {
        while (data.rows.length) {
          var row=data.rows.shift();
          filters[0].documents.push([row.key, row.id]);
        }
        Maps.event.addListener(map, 'bounds_changed', call.this_one_next(update_items));
        Maps.event.trigger(map, 'bounds_changed');
      }, "json");
    });
    // get doc types and set colors
    $.getJSON("_view/fields-values?group_level=2", function(data) {
      var fields={_id:null};
      var types={};
      while (data.rows.length) {
        var key=data.rows.shift().key;
        fields[key[1]]=null;
        types[key[0]]=null;
      }
      var optgroup=$("[name=fields]");
      for (var field in fields)
        optgroup.append($("<option>").text(field));
      var span=$("#filter .types");
      for (var type in types) {
        span.append($('<input>').attr({type:"checkbox",name:type}), type);
        filters[0].types.push(type);
        // This is one rare advantage of javascripts 'phony' arrays:
        // I can use fillColors first as a set and then assign keys
        // to each element!! How nice!!!
        fillColors[type] = fillColors[type] || fillColors.shift();
      }
    });
  });

  // Refine document list if date has changed.
  $("#filter [name=time]").keypress( function(e) {
    if (e.originalEvent && e.which!==13) return;
    var time=$(this).val();
    filter_documents({ time:time });
    var li=$("#time-is");
    // This way the filter shows up at the end of the list instead of at
    // the beginning. It is completely useless but I certainly like it.
    if (li.css("display")==="none")
      $("#cuts").append(li.show());
    li.find('a').text($(this).val());
    if (!time) li.hide();
  });

  // Remove document time constraint.
  $("#time-is :button").click(function() {
    filter_documents({ time:"" });
    $("#filter [name=time]").val('');
    $("#time-is").hide();
  });

  // Refine document list if types have changed.
  $("#filter .types").change( function() {
    var types=[];
    $("#filter .types :checked").each(function() {
      types.push($(this).prop('name'));
    });
    // If no types are selected we might as well select all of
    // them, because no-one really wants to see an empty list.
    if (!types.length) types=filters[0].types;
    // Update the list of fields to show only those
    // that are available by the given type selection.
    $.getJSON("_view/fields-values?group_level=2", function(data) {
      var fields={_id:null};
      for (var t=0;t<types.length;t++)
        fields[types[t]]=null;
      while (data.rows.length) {
        var key=data.rows.shift().key;
        if (types.indexOf(key[0])===-1) continue;
        fields[key[1]]=null;
      }
      var optgroup=$("#filter [name=fields]");
      var val=$("#filter [name=field]").val();
      $("[name=fields]").html('');
      for (var field in fields)
        optgroup.append($("<option>").text(field));
      // The selected option was destroyed three
      // lines above, so I just re-select it here.
      $("#filter [name=field]").val(val);
      // Remove fields that are in the 'columns' <optgroup> already.
      $("#table [name=columns] option").each( function() {
        delete fields[$(this).val()];
      });
      // Fill 'fields' optgroup with reduced set of fields.
      var optgroup=$("#table [name=fields]");
      for (var field in fields)
        optgroup.append($('<option>').text(field));
    });
    filter_documents({ types:types });
    // It sure would be nice to see the new filter appear
    // in the list, and I am in a good mood right now.
    var li=$("#type-is");
    li.find('a').text(types.join('/'));
    // append filter item at the end instead of inserting it
    if (li.css("display")==="none")
      $("#cuts").append(li.show());
    // hide filter item if it displays every type anyway
    if (types.length===filters[0].types.length)
      li.hide();
  });

  // Remove document type restriction.
  $("#type-is :button").click( function() {
    $("#filter .types :checked").prop('checked', false);
    $("#filter .types").change();
  });

  // Add content-filter on <enter> key press.
  $("#filter [name=content]").keypress( function(e) {
    if (e.originalEvent && e.which!==13) return;
    var cut={
      field:$("#filter [name=field]").val(),
      value:$(this).val().replace(/^\s+|\s+$/g,'') || undefined
    };
    // I've made template filter items at the bottom of the
    // page for the following field/value combinations.
    var id=function(field, value) {
      if (field==="_keyword" && value) return "#contains";
      if (field==="_expression" && value) return "#expression";
      if (field && value) return "#field-is";
      if (field[0]!=='_') return "#has-defined";
    }(cut.field, cut.value);
    if (!id) return;
    filter_documents({ cuts:[cut] });
    var li=$(id).clone();
    li.css('display','inline').prop('id',"");
    li.append(cut.value).find('[name=field]').text(cut.field);
    $("#cuts").append(li);
    li.find(':button').click(function() {
      // Tell filter_documents() to remove cut from the queue and set form
      // fields to its parameters; it is likely that the filter had a
      // spelling error, so I should provide an easy way to correct it.
      $("#filter [name=field]").val( cut.field || "" );
      // update autocomplete source array
      $("#filter [name=field]").change();
      $("#filter [name=content]").val( cut.value || "" );
      cut.remove_me=true;
      filter_documents({ cuts:[cut] });
      li.remove();
    });
    $("#cuts").append(li);
  });

  // Show or Hide #keep-selection.
  $("#cuts").click( function() {
    var ol=$(this);
    var li=$("#keep-selection");
    if (ol.find(".filter-item:visible").length)
      ol.append(li.show());
    else li.hide();
  });
  $("#filter .types").change( function() { $("#cuts").click(); });
  $("#filter").keypress( function(e) {
    if (!e.originalEvent || e.which===13)
      $("#cuts").click();
  });

  // Add filtered document to #union filter item and copy the filter list into
  // it; this serves neatly as a description of with which documents the union
  // is constructed.
  $("#keep-selection :button").click( function() {
    var union=$("#union");
    var span=union.find("span");
    if (union.css('display')!=='none')
      span.append(' <b>&cup;</b> ');
    $("#cuts > [id!=keep-selection][id!=union]:visible").each( function() {
      var li=$("<li>").html($(this).html());
      li.find(":button").remove();
      span.append(li.html());
    });
    $("#cuts").prepend(union.css('display', 'block'));
    $("#cuts > [id^=spatial-]").hide();
    filter_documents( {union:filters[filters.length-1].documents}, {spatial:false} );
  });

  // Discard stored selection and hide #union filter item.
  $("#discard-selection").click( function() {
    // also clear selection summary
    $("#union").hide().find("span").html('');
    filter_documents({ union:[] });
  });

  // Filter geometry by spatial relation.
  $("#union > :button").click( function() {
    var relation=$(this).prop('name');
    var keys=[], documents=filters[0].union;
    for (var d=0, id=null; d<documents.length; d++)
      if (id!==documents[d][0])
        keys.push(id=documents[d][0]);
    var union=$("#union");
    // copy filter description into geometry filter item
    var li=$("#spatial-"+relation).css('display', 'block')
                                  .find("span")
                                  .html(union.find("span").html());
    union.hide().find("span").html('');
    filter_documents( {union:[]}, {spatial:relation, keys:keys} );
  });

  // Remove spatial filter.
  $("#cuts > [id^=spatial-] :button").click( function() {
    filter_documents({ spatial:false });
    $("#cuts > [id^=spatial-]").hide();
  });

  // Update autocomplete source array.
  $("#filter [name=field]").change( function() {
    // clear text input on field change.
    var input=$("#filter [name=content]");
    input.val('');
    var field=$(this).val();
    if (!$(this).find("[name=fields] :selected").length) {
      input.autocomplete({source:[]});
      return;
    }
    var types=$("#filter .types :checked");
    if (!types.length) types=$("#filter .types :checkbox");
    // Hash each label to null.
    var labels={};
    // Set-up autocomplete to match the text input's value
    // as regular expression against a list of suggestions.
    function source(request, response) {
      var data=[];
      var matcher=new RegExp(request.term, "i");
      for (var label in labels) {
        label=label.substr(1);
        if (matcher.test(label))
          data.push({ label:label, value:label.replace(/[.*+?^=!:${}()|\[\]\/\\]/g, "\\$&") });
        if (data.length===50) break;
      }
      response(data);
    }
    input.autocomplete({ minLength:0, source:source });
    types.each(function() {
      var type=$(this).prop('name');
      var options={
        group:true, inclusive_end:false, descending:true,
        start_key:JSON.stringify([type, field+' ']),
        end_key:JSON.stringify([type, field])
      }
      $.getJSON("_view/fields-values", options, function(data) {
        while (data.rows.length) {
          var row=data.rows.pop();
          // Do not suggest numbers or objects right now.
          if (row.value.type!=="string") continue;
          labels['_'+row.key[2]]=null;
        }
      });
    });
  });

  // Add or remove column to #table.
  $("#table [name=field]").change( function() {
    var select=$(this);
    // Get selected option and find out in wich <optgroup> it belongs.
    var option=select.find(":selected");
    if (select.find("[name=columns] :selected").length) {
      // remove th from #table
      $("#table thead .field").each( function() {
        var th=$(this);
        if (th.val()!==option.val()) return;
        th.remove();
        return false;
      });
      // move option back to the fields optgroup
      select.find("[name=fields]").prepend(option);
    } else {
      var last=$("#table thead th").last();
      var th=$('<th>').text(option.val())
                      .val(option.val())
                      .addClass("field")
                      .click( function() { select.val($(this).text()).change(); });
      th.html(path.pretty(th.html(), '<br>'));
      // append new header and move column selection to the right
      $("#table thead tr").append(th, last);
      // move option to the columns optgroup
      select.find("[name=columns]").append(option);
    }
    // unselect column
    select.val('');
    for (var id in items) {
      items[id].keep_documents=false;
      items[id].keep_shape=true;
    }
    call.this_one_next(update_geometry)();
  });

  // Toggle document time.
  $("#table th.title-time").click( function() {
    var th=$(this);
    var cl=th.prop('class');
    th.removeClass(cl);
    if (cl==="title") th.addClass("title-time");
    if (cl==="title-time") th.addClass("title");
    for (var id in items) {
      items[id].keep_documents=false;
      items[id].keep_shape=true;
    }
    call.this_one_next(update_geometry)();
  });

  // cycle through geometric detail mode:
  // 'refine' <-> 'precise' -> 'simplified' -> 'refine'
  $("#settings [name=refine]").click( function() {
    $("#settings [name=refine]").hide();
    $("#settings [name=precise]").show();
    // show refined geometry once, and
    for (var id in items) {
      items[id].keep_shape=(items[id].keys[0][1]===0);
      items[id].keys[0][1]=0;
    }
    call.this_one_next(update_geometry)();
    // revert to 'refine', if viewport was moved
    Maps.event.addListenerOnce(map, 'bounds_changed', function() {
      $("#settings [name=precise]").hide();
      $("#settings [name=refine]").show();
    });
  });

  $("#settings [name=precise]").click( function() {
    $("#settings [name=precise]").hide();
    $("#settings [name=simplified]").show();
    Maps.event.clearListeners(map, 'bounds_changed');
    Maps.event.addListener(map, 'bounds_changed', call.this_one_next(function() {update_items(0);}));
  });

  $("#settings [name=simplified]").click( function() {
    $("#settings [name=simplified]").hide();
    $("#settings [name=refine]").show();
    Maps.event.clearListeners(map, 'bounds_changed');
    Maps.event.addListener(map, 'bounds_changed', call.this_one_next(update_items));
    Maps.event.trigger(map, 'bounds_changed');
  });

  // increase limit to next higher [1,2,5,10,20,50,etc]
  $("#settings [name=more]").click( function() {
    var limit=parseFloat($("#settings [name=limit]").val());
    var new_limit=10;
    while (new_limit<=limit) new_limit*=10;
    if (new_limit>5*limit) new_limit/=5;
    if (new_limit>2*limit) new_limit/=2;
    $("#settings [name=limit]").val(new_limit);
    Maps.event.trigger(map, 'bounds_changed');
  });

  // decrease limit to next lower [1,2,5,10,20,50,etc]
  $("#settings [name=less]").click( function() {
    var limit=parseFloat($("#settings [name=limit]").val());
    var new_limit=1;
    while (new_limit*10<limit) new_limit*=10;
    if (new_limit*5<limit) new_limit*=5;
    if (new_limit*2<limit) new_limit*=2;
    $("#settings [name=limit]").val(new_limit);
    // remove populated-viewport-notification
    viewports[viewports.length-1].populated=false;
    Maps.event.trigger(map, 'bounds_changed');
  });

  // Suppress page load if user presses enter in any
  // text input and update map if anything changed.
  $("#settings").change( function() {
    Maps.event.trigger(map, 'bounds_changed');
  });

  $("form").submit( function(e) {e.preventDefault();} );

  $("#export [name=download]").add("#export [name=get-url]")
                              .click( function() {
    var url="_list/export/geojson";
    url+="?filename="+$("#export [name=filename]").val();
    url+="&filetype="+$("#export [name=filetype]:checked").val();
    var documents=filters[filters.length-1].documents;
    var keys=[], id=null;
    // ignore geometry keys for xml
    var include_geometry=$("#export [name=filetype]:checked").val()!=="xml";
    for (var d=0;d<documents.length;d++) {
      var key=documents[d];
      if (include_geometry && id!==key[0]) keys.push([key[0],0]);
      keys.push(key);
      id=key[0];
    }
    if ($("#export [name=include-revision]").prop('checked'))
      url+="&include_revision";
    if ($("#export [name=include-geojson-id]").prop('checked'))
      url+="&include_geojson_id";
    if ($("#export [name=select-fields]:checked").val()==="from-table") {
      var fields=[];
      $("#table thead .field").each(function() { fields.push($(this).val()); });
      url+="&fields="+fields.join(':').replace(/\+/g,'%2B').replace(/\s/g,'%20');
    }
    var translate_url=({
      'download':function(url) { window.open(url+"&download", "_self"); },
      'get-url':function(url) {
        url=window.location.origin+'/'+list.db+'/'+list.app+'/'+url;
        // hide download button
        $("#export [name=get-url]").hide();
        // display the url in a selected text input
        $("#export [name=url]").val(url).show().focus().select();
      }
    })[$(this).prop('name')];
    // Provide a permanent link if the URI is small.
    keys=JSON.stringify(keys);
    if (keys.length<=4096) {
      translate_url(url+"&keys="+keys);
      return;
    }
    // Otherwise employ index compression.
    $.getJSON("_view/geojson-doc", function(data) {
      // get document order identical to _view/geojson
      var rows=data.rows;
      for (var k=0;k<rows.length;k++)
        rows[ [rows[k].key,rows[k].id] ] = k;
      var list=[];
      for (var d=0;d<documents.length;d++)
        list.push(rows[ documents[d] ]);
      // Compute start_key and end_key to reduce amount of rows that
      // are JSON.parse'ed and then just skipped by _list/export.
      indexes.sort(list);
      var offset=list[0];
      while (offset && rows[offset].key===rows[offset-1].key)
        offset--;
      url+="&start_key="+JSON.stringify([rows[offset].key, 0]);
      var end_row=rows[list[list.length-1]];
      url+="&end_key="+JSON.stringify([end_row.key, end_row.id]);
      for (var i=0;i<list.length;i++) list[i]-=offset;
      translate_url(url+"&compressed_keys="+indexes.compress(list));
    });
  });

  // Hide url text input and display 'get-url' again.
  $("#export [name=url]").focusout( function() {
    $(this).hide();
    $("#export [name=get-url]").show();
  });

  $("#export [name=filetype]").change( function() {
    var elements=$("#export [name=columns]")
                 .add("#export [name=download]")
                 .add("#export [name=get-url]");
    if ($(this).val()==="couchdb") {
      elements.hide();
      $("#export [name^=replicate]").show();
      $.getJSON("/_all_dbs", function(dbs) {
        // remove _special dbs and own from suggestion list
        for (var d=0;d<dbs.length;d++)
          if (dbs[d]===list.db || dbs[d][0]==="_") dbs.splice(d--,1);
        $("#export [name=filename]").autocomplete({
          source:dbs, minLength:0,
          position:{my:"left bottom", at:"left top"}
        });
      });
    } else {
      elements.show();
      $("#export [name^=replicate]").hide();
      $("#export [name=filename]").autocomplete({source:[]});
    }
  });

  $("#export [name=replicate]").click( function() {
    $(this).prop('disabled', true);
    var data={
      source:list.db, create_target:true,
      target:$("#export [name=filename]").val(),
      doc_ids:[list.app]
    };
    var documents=filters[0].documents;
    for (var k=0, d=0; k<keys.length; k++) {
      while (documents[d][0]!==keys[k]) d++;
      while (documents[d][0]===keys[k])
        data.doc_ids.push(documents[d++][1]);
    }
    $.ajax("/_replicate", {
      type:"POST", dataType:"json",
      contentType:"application/json",
      data:JSON.stringify(data),
      complete:function(jqXHR, textStatus) {
        JQXHR=jqXHR;
        var resp=jqXHR.responseJSON || {status:textStatus};
        var lines=[];
        for (var prop in resp) {
          if (typeof resp[prop] === "object") continue;
          if (typeof resp[prop] === "function") continue;
          lines.push(prop+': <b>'+resp[prop]+'</b>');
        }
        $("#export [name=replicate-status]").html(lines.join(',<br>'));
        $("#export [name=replicate]").prop('disabled', false);
        if (textStatus!=="success") return;
        $("#export [name=replicate]").hide();
        $("#export [name=replicant]").attr({
          href:"../../../"+data.target+'/'+list.app+"/index.html"
        }).show().focus();
      }
    });
  });

  // Hide db link and display 'replicate' again.
  $("#export [name=replicant]").focusout( function() {
    $(this).hide();
    $("#export [name=replicate]").show();
  });

  $("#export [name=filename]").keypress( function(e) {
    if (e.which!==13) return;
    $("#export [name=download]:visible").click();
    $("#export [name=replicate]:visible").click();
  });

});
</script>

<style>
  #settings .geometry-level {width:6em}
  #settings span, #filter span, #export span {white-space:nowrap}
  #filter span.types, #cuts span {white-space:normal}
  label, span.nowrap {white-space:nowrap}
  #cuts li {display:inline}
  table, th, tr, td {
    padding:0; padding-right:3px;
    border-collapse:collapse;
    vertical-align:top
  }
  #table a:focus {font-weight:bold}
  #table td.geometry:hover,
  #table th.field:hover,
  #table th.title:hover,
  #table th.title-time:hover,
  #table td span.field:hover {cursor:pointer}
  #table .geometry {font-weight:900}
</style>

  </head>
  <body style="height:90%">

  <iframe src="login_bar.htm" style="width:100%; height:1.6em; border:0;"></iframe>

  <h1> Karte </h1>
  <form id="settings"> Darstellung:
    <input type="button" name="refine" class="geometry-level" value="verfeinern">
    <input type="button" name="precise" class="geometry-level" value="exakt" style="display:none">
    <input type="button" name="simplified" class="geometry-level" value="vereinfacht" style="display:none">
    <label><input type="checkbox" name="delayed">verzögert</label>
    <label><input type="text" name="limit" size=2 value="50">Polygone</label>
    <span class="nowrap">
      <input type="button" value="weniger" name="less">
      <input type="button" value="mehr" name="more"></span>
  </form>
  <div id="map" style="height:65%"></div>
  <form id="filter"> Filter:
    <span class="types"></span><br>
    <label>von: <input type="text" size=8 name="time" title="Zeit"></label>
    <label>enthält: <input type="text" size=24 name="content" title="Stichwort/Suchbegriff"></label>
    <label>als: <select name="field">
      <option value="_keyword">Text</option>
      <option value="_expression">Funktion</option>
      <optgroup name="fields" label="Felder"></optgroup>
    </select></label>
    <ol id="cuts">
      <!-- default filter list items -->
      <li style="display:none" id="type-is" class="filter-item">
        <input type="button" value="x" title="löschen"> <a></a></li>
      <li style="display:none" id="time-is" class="filter-item">
        <input type="button" value="x" title="löschen"> <b>Zeit:</b> <a></a></li>
      <li style="display:none" id="contains" class="filter-item">
        <input type="button" value="x" title="löschen"> <b>enthält</b> </li>
      <li style="display:none" id="has-defined" class="filter-item">
        <input type="button" value="x" title="löschen"> <b name="field"></b> zugewiesen</li>
      <li style="display:none" id="field-is" class="filter-item">
        <input type="button" value="x" title="löschen"> <b name="field"></b> </li>
      <li style="display:none" id="expression" class="filter-item">
        <input type="button" value="x" title="löschen"> <b>erfüllt</b> </li>
      <!-- always show selected docs -->
      <li style="display:none" id="keep-selection">
        <input type="button" value="Auswahl merken"></li>
      <!-- union with stored selection -->
      <li style="display:none" id="union">
        <input type="button" value="x" title="löschen" id="discard-selection">
        <b>Auswahl:</b> <span></span><br>
        <input type="button" value="umgibt" name="contains">
        <input type="button" value="schneidet" name="intersects">
        <input type="button" value="innerhalb" name="within">
      </li>
      <!-- stored selection related to active selection -->
      <li style="display:none" id="spatial-contains">
        <input type="button" value="x" title="löschen">
        <span></span> <b>umgibt:</b>
      </li>
      <li style="display:none" id="spatial-intersects">
        <input type="button" value="x" title="löschen">
        <span></span> <b>überschneidet sich mit:</b>
      </li>
      <li style="display:none" id="spatial-within">
        <input type="button" value="x" title="löschen">
        <span></span> <b>befindet sich innerhalb:</b>
      </li>
    </ol>
  </form>
  <table id="table">
    <thead><tr>
      <!-- link to highlight geometry in the map canvas -->
      <th class="geometry"><span style="display:none">&bull;</span></th>
      <th class="title-time">Beschreibung</th>
      <th><select name="field">
        <!-- unselect any column on page load -->
        <option selected style="display:none"></option>
        <optgroup name="fields" label="neue Spalte"></optgroup>
        <optgroup name="columns" label="Spalte löschen"></optgroup>
      </select></th>
    </tr></thead>
    <tbody></tbody>
  </table>
  <form id="export">
    Auswahl
    <label>als <input type="text" value="export" name="filename"></label>
    <label><input type="radio" name="filetype" value="geojson" checked>.geojson</label>
    <label><input type="radio" name="filetype" value="xml">.xml-Tabelle</label>
    <label><input type="radio" name="filetype" value="couchdb">CouchDB</label>
    <span class="nowrap">
      <input type="button" value="speichern" name="download">
      <input type="button" value="URL erzeugen" name="get-url"></span>
    <input type="text" name="url" style="display:none">
    <span name="columns" class="nowrap">
      <label><input type="radio" name="select-fields" checked>alle</label>
      <label><input type="radio" name="select-fields" value="from-table">ausgewählte Spalten</label></span>
    <span name="columns" class="nowrap">
      <label><input type="checkbox" name="include-revision" checked>_id, _rev</label>
      <label><input type="checkbox" name="include-geojson-id" checked>Geometrie-Schlüssel</label></span>
    <input type="button" value="replizieren" name="replicate" style="display:none">
    <a name="replicant" target="_blank" style="display:none">zur Datenbank wechseln</a><br>
    <a name="replicate-status" style="display:none"></a>
  </form>
  </body>
</html>
