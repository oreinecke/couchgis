<!DOCTYPE html>

<html lang="de" style="height:125%">
  <head>
    <title>Karte</title>
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8">
    <link href="css/jquery-ui-1.10.4.custom.css" rel="stylesheet">
    <script src="script/jquery-1.10.2.min.js"></script>
    <script src="script/jquery-ui-1.10.4.custom.js"></script>
    <script src="script/require.js"></script>
    <script type="text/javascript" src="https://maps.googleapis.com/maps/api/js?v=3.15&sensor=false"></script>
    <script src="script/google.maps.js"></script>
    <script src="script/fillColors.js"></script>

<script type="text/javascript">
$(document).ready(function() {

  var map = new Maps.Map($('#map')[0], {
    zoom: 12,
    mapTypeId: Maps.MapTypeId.SATELLITE,
    center: new LatLng(50.83730534254573, 13.938310197234163)
  });

  var path=require('views/lib/path');
  var range=require('views/lib/range');
  var indexes=require('views/lib/indexes');

  // call _list/bbox-filter/<view> with some useful options
  function list(list, options, success) {
    var keys=options.keys;
    delete options.keys;
    list+="?options="+encodeURIComponent(JSON.stringify(options));
    $.ajax("_list/"+list, {
      type:"POST",
      dataType:"json",
      data:JSON.stringify({keys:keys}),
      success:success,
      error:call.that_last_one
    });
  }
  // ok this also looks retarded but it keeps my stuff in one place at least
  list.parts=window.location.pathname.split('/');
  list.db=list.parts[1];
  list.app=list.parts[3];
  delete list.parts;

  // It is very likely that the oftentimes inexperienced user clicks and
  // scrolls the map like an ape (on adderall). Then, event handler callbacks
  // will be fired all over the place and the interface probably won't react
  // anymore. It should be smarter than that; It should wait a couple of
  // seconds, then wait for the last ajax to complete, then do the next thing
  // that needs to be done.
  var call={
    now:null, next:null,
    this_one_next:function(what) {
      // We might as well do the closure here, because this
      // is used only for event handler registration anyway.
      return function() {
        if (call.now!==null) call.next=what;
        else (call.now=what)();
      }
    },
    that_last_one:function() {
      window.setTimeout(function() {
        call.now=call.next;
        call.next=null;
        if (call.now!==null) call.now();
      }, 500);
    },
    no_one:function() {
      call.now=null;
      call.next=null;
    }
  };
  // All items that are displayed on the map are in here as "id":{etc.}.
  var items={};
  // This contains an ordered list of ALL GeoJSON keys.
  var keys=[];
  // This contains a cascading viewport array,
  // initialized to one default element.
  var viewports=[{
    bbox: [-Infinity,-Infinity,Infinity,Infinity],
    prefix: [], // (limited) items returned by this viewport
    position: 0 // index from which to append remaining keys
  }];
  // Same as viewports for content-based filters.
  var filters=[{ types:[], time:"", documents:[] }];

  // query for GeoJSON and full documents
  function update_geometry() {
    var keys=[];
    for (var id in items) {
      var item=items[id];
      if (!item.keep_shape)
        keys.push(item.keys[0]);
      if (!item.keep_documents)
        keys=keys.concat(item.keys.slice(1));
    }
    if (!keys.length) {
      call.that_last_one();
      return;
    }
    var successful=false;
    function ajax() {
      $.ajax("_view/geojson", {
        type:"POST",
        data:'{"keys":'+JSON.stringify(keys)+'}',
        dataType:"json",
        success:success,
        complete:function() {
          // Sadly, this seems to be the only way to catch
          // CouchDB's internal server error or whatever this is.
          if (!successful)
            window.setTimeout(ajax, 50);
        }
      });
    }
    ajax();
    // Even more sad: I need to add this timer
    // because Chrome does not call 'complete'.
    window.setTimeout(function() { if (!successful) ajax(); }, 3000);
    function success(data) {
      successful=true;
      // timeout is 5ms or instantaneous
      var timeout = 5 * $("#settings [name='delayed']").prop('checked');
      (function update_one_geometry() {
        while (data.rows.length) {
          var row=data.rows.shift();
          var item=items[row.key[0]];
          if (row.value.doc) {
            data.rows.unshift(row);
            var tr=item.tr;
            tr.html('');
            var headers=$("#table th");
            // append <th>'s from headers as <td>'s and copy class name
            headers.each(function() { tr.append($("<td>")); });
            var columns=tr.find("td");
            var fillColor=null;
            for (var d=1;d<item.keys.length;d++) {
              // Group docs with identical GIS into one li.
              var doc=data.rows.shift().value.doc;
              if (!fillColor) fillColor=fillColors[doc.type];
              headers.each(function(i) {
                var th=$(this);
                var td=$(columns[i]);
                var cl=th.prop('class');
                if (cl==="document")
                // Link to Futon for the lack of a better interface
                // and set link text to a useful item explanation.
                  td.append($("<a>").attr({
                    href:"/_utils/document.html?"+list.db+'/'+doc._id, target:"_blank"
                  }).html( (doc[doc.type]||doc.type) + ' ' +
                           ('('+range.toString(doc.time)+')').replace('()',"") )
                  ).append("<br>");
                // evaluate columns
                else if (cl==="field") {
                  var fields=path.decode(th.val()), value=doc;
                  while (fields.length && value!=null) value=value[fields.shift()];
                  td.append(value+'<br>');
                }
                if (cl!=="geometry") return;
                // Set-up link to geometry: I use a very bold bullet point.
                td.html('<a href="#settings" style="font-weight:900">&bull;</a>');
                td.find("a").click(function(item) { return function() {
                  // Center map to the shape and highlight it.
                  var bbox=item.GeoJSON.bbox;
                  map.setCenter(new LatLng((bbox[3]+bbox[1])/2.0+offset[1],
                                           (bbox[2]+bbox[0])/2.0+offset[0]));
                  item.shape.setOptions({strokeColor:"#FF0000", zIndex:new Date().getTime()});
                  $("#table tbody").prepend(item.tr);
                } }(item) );
              });
            }
            // If colored black, (Multi)LineStrings are difficult to spot on the map.
            if (item.shape instanceof Maps.Polygon || item.shape instanceof MultiPolygon)
              item.shape.setOptions({fillColor:fillColor});
            else item.shape.setOptions({strokeColor:fillColor});
            item.keep_documents=true;
            continue;
          }
          var options=expand_options({ coordinates:row.value.GeoJSON.coordinates, map:map});
          if (item.shape==null) {
            item.shape=create_shape(row.value.GeoJSON.type, options);
            item.shape.addListener('click', function(tr) {
              return function() {
                this.setOptions({zIndex:-new Date().getTime()});
                $("#table tbody").prepend(tr);
                // IE-10.0 loses this <a>'s focus because the map was clicked
                // once before. It works just fine if we delay it by 1ms.
                window.setTimeout(function() { tr.find('a').last().focus(); }, 1);
              };
            }(item.tr));
          } else item.shape.setOptions(options);
          if (!timeout) continue
          window.setTimeout(update_one_geometry, timeout);
          return;
        }
        call.that_last_one();
      })();
    }
  }

  // diff-updates items inside viewport
  function update_items(error) {
    var NE=map.getBounds().getNorthEast();
    var SW=map.getBounds().getSouthWest();
    var options={
      limit:parseFloat($("#settings [name='limit']").val()),
      error:(error===undefined ? (NE.lat()-SW.lat())/100 : error),
      bbox:[
        SW.lng()-offset[0], SW.lat()-offset[1],
        NE.lng()-offset[0], NE.lat()-offset[1]
      ],
    };
    var vp;
    // pop viewports until one is found that surrounds bbox
    do vp=viewports.pop();
    while (options.bbox[0]<vp.bbox[0]||options.bbox[1]<vp.bbox[1]||
           options.bbox[2]>vp.bbox[2]||options.bbox[3]>vp.bbox[3]);
    // the last viewport is valid, so it needs to be re-stacked
    viewports.push(vp);
    // abort if we already see less items than requested
    if (vp.populated) {
      call.that_last_one();
      return;
    }
    // ignore items that were already dropped by previous viewport
    options.keys=vp.prefix.concat(keys.slice(vp.position));
    var table = $("#table tbody");
    list("bbox-filter/bbox", options, function(data) {
      var position=0;
      // lists items to be removed as {id:null}
      var old_items={};
      for (var id in items) old_items[id]=null;
      // prepare new viewport
      var new_vp={ bbox:options.bbox, prefix:[] };
      var documents=filters[filters.length-1].documents;
      // I need the last prop of data after the loop again. This is one
      // exceptional case where no 'var' is found in a for-statement.
      var id; for (id in data) {
        new_vp.prefix.push(id);
        if (items[id]) {
          delete old_items[id];
          var KEYS=items[id].keys;
          items[id].keep_shape=(KEYS[0][1]===data[id].GeoJSON.error);
          KEYS[0][1]=data[id].GeoJSON.error;
          continue;
        }
        items[id]=data[id];
        var tr=$("<tr>");
        table.append(tr);
        items[id].tr=tr;
        // fetch GeoJSON of specified detail level
        var KEYS=[[id, data[id].GeoJSON.error]];
        // skip to matching document id
        while (documents[position][0]!==id)
          position=(position+1)%documents.length;
        // add all associated documents
        while (position<documents.length && documents[position][0]===id)
          KEYS.push(documents[position++]);
        items[id].keys=KEYS;
      }
      if (new_vp.prefix.length<options.limit) {
        // note that we've retrieved all items with this viewport
        new_vp.populated=true;
        // set full detail level automatically in this case
        if (error!==0) for (var id in data) {
          // keep items that are already displayed
          items[id].keep_shape=items[id].shape && (items[id].keys[0][1]===0);
          items[id].keys[0][1]=0;
        }
      }
      // If the query returned less than the required items, then these must
      // be the only items within the viewport. In this case the index may be
      // set to the end of the list, and no keys are appended.
      if (new_vp.prefix.length<options.limit) new_vp.position=keys.length;
      // In any other case it is safe to assume that any key before the
      // last one is either outside the viewport or already in prefix.
      else new_vp.position=keys.indexOf(id)+1;
      // Add new_vp to viewport stack, but only if it is indeed more restrictive.
      if (new_vp.position>vp.position || new_vp.prefix.length<vp.prefix.length)
        viewports.push(new_vp);
      // remove out-of-viewport shapes and links
      for (var id in old_items) {
        items[id].shape.setMap();
        items[id].tr.remove();
        delete items[id];
      }
      // Fetch changed geometries in 50 ms.
      window.setTimeout(update_geometry, 50);
    });
  }

  // Applies new filter to document list; new_filter must be a single-member
  // object denoting the filter type. It is then either
  // i) attached at the end of the filter queue
  // ii) inserted in the middle and merged with filters following it
  // iii) nothing of the above if an identical filter is already used.
  function filter_documents(new_filter) {
    // Aquire (single) property name of new_filter.
    var filter_name=function() {for (var prop in new_filter) return prop;}();
    // In any case, we can use the full, non-filtered document list.
    var documents=filters[0].documents;
    // Remind me if we already have an identical filter in place.
    var equal_filter=false;
    var position=0;
    // Check what document list to reuse: As soon as a conflicting (that is
    // non-containing) filter is found, this one and every filter following it
    // need to be re-evaluated.
    while ( position<filters.length && (function(filter) {
      // In this part we determine for each filter type if it
      // a) is more restrictive than an already applied filter, and
      // b) happens to be identical to said filter.
      // I have written this part using an anonymous function because it is
      // most concise and every attempt to do this without resulted in
      // additional clutter. Also I expect filters.length not to exceed 20.
      if (filter[filter_name]==null) return true;
      if (filter_name==="time") {
        var contains=(range.contains(filter.time, new_filter.time));
        if (contains) equal_filter=(range.contains(new_filter.time, filter.time));
        return contains;
      }
      if (filter_name==="types") {
        var contains=(new_filter.types.length<=filter.types.length);
        for (var t=0; contains && t<new_filter.types.length; t++)
          contains &= (filter.types.indexOf(new_filter.types[t])>=0);
        if (contains) equal_filter=(new_filter.types.length===filter.types.length);
        return contains;
      }
      if (filter_name==="cuts") {
        var cut=new_filter.cuts[0];
        if (!cut.remove_me) return true;
        var index=filter.cuts.indexOf(cut);
        if (index===-1) return true;
        filter.cuts.splice(index,1);
        delete new_filter.cuts;
        return false;
      }
    }(filters[position])) )
      // If the last filter was compatible, we can use its document list.
      documents=filters[position++].documents;
    filters.push(new_filter);
    var options={cuts:[]};
    // Collapse remaining filters into options.
    for (var filter; filter=filters.splice(position,1)[0]; ) {
      if ('time' in filter) options.time=filter.time;
      if ('types' in filter) options.types=filter.types;
      if ('cuts' in filter) options.cuts=options.cuts.concat(filter.cuts);
    }
    // Generate geometry id list from latest document list and
    // reset viewports because they are most likely invalidated.
    function reset_viewports() {
      var documents=filters[filters.length-1].documents;
      keys.splice(0);
      viewports.splice(1);
      var old_id=null;
      for (var d=0;d<documents.length;d++) {
        var id=documents[d][0];
        if (old_id===id) continue;
        keys.push(id);
        old_id=id;
        if (!items[id]) continue;
        var old_keys=items[id].keys;
        old_keys.splice(1);
        while (d<documents.length && old_id===documents[d][0])
          old_keys.push(documents[d++]);
        // update document list in the next _view/geojson
        items[id].keep_documents=false;
        // the nested loop results in an off-by-one document index
        d--;
      }
//    window.setTimeout(function() { Maps.event.trigger(map, 'bounds_changed'); },50);
      Maps.event.trigger(map, 'bounds_changed');
    }
    // Remove options.cuts array if empty.
    if (!options.cuts.length) delete options.cuts;
    // Remove filter from options if an identical one has already been applied.
    if (equal_filter) delete options[filter_name];
    // Avoid query if all filters have been removed from options.
    if (function() { for (var prop in options) return false; return true; }()) {
      reset_viewports();
      return;
    }
    options.keys=documents;
    list("tabulate/geojson", options, function(data) {
      var new_documents=[], d=0;
      for (var i=0;i<data.length;i++) {
        var doc_id=data[i];
        while (documents[d][1]!=doc_id) d++;
        new_documents.push(documents[d]);
      }
      options.documents=new_documents;
      delete options.keys;
      filters.push(options);
      reset_viewports();
    });
  }

  // Initialize map position and geometry as soon as map has finished loading.
  Maps.event.addListenerOnce(map, 'tilesloaded', function() {
    // set viewport and zoom level
    $.getJSON("_view/dimensions", function(data) {
      var bbox=data.rows[0].value.bbox;
      map.setCenter(new LatLng((bbox[3]+bbox[1])/2.0, (bbox[2]+bbox[0])/2.0));
      // also initialize the time text field
      $("#filter [name='time']").val(range.toString(data.rows[0].value.range));
    });
    // get list of GeoJSON keys, largest to smallest item
    $.getJSON("_view/dimensions?reduce=false&descending=true&end_key=0", function(data) {
      while (data.rows.length)
        keys.push(data.rows.shift().id);
      // update GeoJSON according to viewport
      // get associated document ids
      $.post("_view/geojson-doc", JSON.stringify({keys:keys}), function(data) {
        while (data.rows.length) {
          var row=data.rows.shift();
          filters[0].documents.push([row.key, row.id]);
        }
        Maps.event.addListener(map, 'bounds_changed', call.this_one_next(update_items));
        Maps.event.trigger(map, 'bounds_changed');
      }, "json");
    });
    // get doc types and set colors
    $.getJSON("_view/fields-values?group_level=2", function(data) {
      var options={};
      var inputs={};
      while (data.rows.length) {
        var key=data.rows.shift().key;
        options[key[1]]=null;
        inputs[key[0]]=null;
      }
      var optgroup=$("[name='fields']");
      for (var field in options)
        optgroup.append('<option>'+field+'</option>');
      var span=$("#filter .types");
      for (var type in inputs) {
        span.append('<input type="checkbox" name="'+type+'">'+type);
        filters[0].types.push(type);
        // This is one rare advantage of javascripts 'phony' arrays:
        // I can use fillColors first as a set and then assign keys
        // to each element!! How nice!!!
        fillColors[type] = fillColors[type] || fillColors.shift();
      }
    });
  });

  // Refine document list if date has changed.
  $("#filter [name='time']").keypress( function(e) {
    if (e.which!==13) return;
    filter_documents({ time: $(this).val() });
    var li=$("#time-is");
    // This way the filter shows up at the end of the list instead of at
    // the beginning. It is completely useless but I certainly like it.
    if (li.css("display")==="none")
      $("#cuts").append(li.show());
    li.find('a').html($(this).val());
    li.find(':button').off().click(function() {
      filter_documents({time:""});
      $("#filter [name='time']").val('');
      li.hide();
    });
  });

  // Refine document list if types have changed.
  $("#filter .types").change( function() {
    var types=[];
    $("#filter .types :checked").each(function() {
      types.push($(this).prop('name'));
    });
    // If no types are selected we might as well select all of
    // them, because no-one really wants to see an empty list.
    if (!types.length) types=filters[0].types;
    // Update the list of fields to show only those
    // that are available by the given type selection.
    $.getJSON("_view/fields-values?group_level=2&group=true", function(data) {
      var options={};
      while (data.rows.length) {
        var key=data.rows.shift().key;
        if (types.indexOf(key[0])===-1) continue;
        options[key[1]]=null;
      }
      var optgroup=$("#filter [name='fields']");
      var val=$("#filter [name='field']").val();
      $("[name='fields']").html('');
      for (var field in options)
        optgroup.append('<option>'+field+'</option>');
      // The selected option was destroyed three
      // lines above, so I just re-select it here.
      $("#filter [name='field']").val(val);
      // Remove options that are in the 'columns' <optgroup> already.
      $("#table [name='columns'] option").each( function() {
        delete options[$(this).val()];
      });
      // Fill 'fields' optgroup with reduced set of options.
      var optgroup=$("#table [name='fields']");
      for (var field in options)
        optgroup.append('<option>'+field+'</option>');
    });
    filter_documents({types:types});
    // It sure would be nice to see the new filter appear
    // in the list, and I am in a good mood right now.
    var li=$("#type-is");
    li.find('a').html(types.join('/'));
    // append filter item at the end instead of inserting it
    if (li.css("display")==="none")
      $("#cuts").append(li.show());
    // hide filter item if it displays every type anyway
    if (types.length===filters[0].types.length)
      li.hide();
    li.find(':button').off().click( function() {
      // Remove all the type checkboxes and run it again.
      $("#filter .types :checked").prop('checked', false);
      $("#filter .types").change();
    });
  });

  // Add content-filter on <enter> key press.
  $("#filter [name='content']").keypress( function(e) {
    if (e.which!==13) return;
    var cut={
      field:$("#filter [name='field']").val(),
      value:$(this).val().replace(/^\s+|\s+$/g,'') || undefined
    };
    // I've made template filter items at the bottom of the
    // page for the following field/value combinations.
    var id=function(field, value) {
      if (field==="_keyword" && value) return "#contains";
      if (field==="_expression" && value) return "#expression";
      if (field && value) return "#field-is";
      if (field[0]!=='_') return "#has-defined";
    }(cut.field, cut.value);
    if (!id) return;
    filter_documents({cuts:[cut]});
    var li=$(id).clone();
    li.css('display','inline').prop('id',"");
    li.find('a').html(cut.value);
    li.find('b').html(cut.field[0]==='_'?undefined:cut.field);
    $("#cuts").append(li);
    li.find(':button').click(function() {
      // Tell filter_documents() to remove cut from the queue and set form
      // fields to its parameters; it is likely that the filter had a
      // spelling error, so I should provide an easy way to correct it.
      $("#filter [name='field']").val( cut.field || "" );
      // update autocomplete source array
      $("#filter [name='field']").change();
      $("#filter [name='content']").val( cut.value || "" );
      cut.remove_me=true;
      filter_documents({cuts:[cut]});
      li.remove();
    });
    $("#cuts").append(li);
  });

  // Update autocomplete source array.
  $("#filter [name='field']").change( function() {
    // clear text input on field change.
    var input=$("#filter [name='content']");
    input.val('');
    var options={ minLength:0, maxItems:50, source:[] };
    var field=$(this).val();
    if (!$(this).find("[name='fields'] :selected").length) {
      input.autocomplete(options);
      return;
    }
    var types=$("#filter .types :checked");
    if (!types.length) types=$("#filter .types :checkbox");
    types.each(function() {
      var type=$(this).prop('name');
      var start_key=encodeURIComponent(JSON.stringify([type, field]));
      var end_key=encodeURIComponent(JSON.stringify([type, field+' ']));
      var url="_view/fields-values?group=true&inclusive_end=false&group=true";
      url+="&start_key="+start_key+"&end_key="+end_key;
      // Store labels as {label:null}.
      var labels={};
      $.getJSON(url, function(data) {
        while (data.rows.length) {
          var row=data.rows.shift();
          // Do not suggest numbers or objects right now.
          if (row.value.type!=="string") continue;
          var label=row.key[2];
          var value=label.replace(/[.*+?^=!:${}()|\[\]\/\\]/g, "\\$&");
          // Suppress duplicate suggestions.
          if (labels[label]===null) continue;
          options.source.push({label:label, value:value});
          labels[label]=null;
        }
        input.autocomplete(options);
      });
    });
  });

  // Add or remove column to #table.
  $("#table [name='field']").change( function() {
    var select=$(this);
    // Get selected option and find out in wich <optgroup> it belongs.
    var option=select.find(":selected");
    if (select.find("[name='columns']").find(option).length) {
      // remove th from #table
      $("#table thead .field").each( function() {
        var th=$(this);
        if (th.val()!==option.val()) return;
        th.remove();
        return false;
      });
      // move option back to the fields optgroup
      select.find("[name='fields']").prepend(option);
    } else {
      var last=$("#table thead th").last();
      $("#table thead tr").append($('<th>').html(path.pretty($(this).val(),'<br>'))
                                           .val($(this).val())
                                           .addClass("field"));
      // move column selection to the right
      $("#table thead tr").append(last);
      var select=$(this);
      // move option to the columns optgroup
      select.find("[name='columns']").append(option);
    }
    // unselect column
    select.val('');
    for (var id in items) items[id].keep_documents=false;
    call.this_one_next(update_geometry)();
  });

  // cycle through geometric detail mode:
  // 'refine' <-> 'precise' -> 'simplified' -> 'refine'
  $("#settings [name='refine']").click( function() {
    $("#settings [name='refine']").hide();
    $("#settings [name='precise']").show();
    // show refined geometry once, and
    for (var id in items) {
      items[id].keep_shape=(items[id].keys[0][1]===0);
      items[id].keys[0][1]=0;
    }
    call.this_one_next(update_geometry)();
    // revert to 'refine', if viewport was moved
    Maps.event.addListenerOnce(map, 'bounds_changed', function() {
      $("#settings [name='precise']").hide();
      $("#settings [name='refine']").show();
    });
  });

  $("#settings [name='precise']").click( function() {
    $("#settings [name='precise']").hide();
    $("#settings [name='simplified']").show();
    Maps.event.clearListeners(map, 'bounds_changed');
    Maps.event.addListener(map, 'bounds_changed', call.this_one_next(function() {update_items(0);}));
  });

  $("#settings [name='simplified']").click( function() {
    $("#settings [name='simplified']").hide();
    $("#settings [name='refine']").show();
    Maps.event.clearListeners(map, 'bounds_changed');
    Maps.event.addListener(map, 'bounds_changed', call.this_one_next(update_items));
    Maps.event.trigger(map, 'bounds_changed');
  });

  // increase limit to next higher [1,2,5,10,20,50,etc]
  $("#settings [name='more']").click( function() {
    var limit=parseFloat($("#settings [name='limit']").val());
    var new_limit=10;
    while (new_limit<=limit) new_limit*=10;
    if (new_limit>5*limit) new_limit/=5;
    if (new_limit>2*limit) new_limit/=2;
    $("#settings [name='limit']").val(new_limit);
    Maps.event.trigger(map, 'bounds_changed');
  });

  // decrease limit to next lower [1,2,5,10,20,50,etc]
  $("#settings [name='less']").click( function() {
    var limit=parseFloat($("#settings [name='limit']").val());
    var new_limit=1;
    while (new_limit*10<limit) new_limit*=10;
    if (new_limit*5<limit) new_limit*=5;
    if (new_limit*2<limit) new_limit*=2;
    $("#settings [name='limit']").val(new_limit);
    // remove populated-viewport-notification
    viewports[viewports.length-1].populated=false;
    Maps.event.trigger(map, 'bounds_changed');
  });

  // Suppress page load if user presses enter in any
  // text input and update map if anything changed.
  $("#settings").change( function() {
    Maps.event.trigger(map, 'bounds_changed');
  });

  $("form").submit( function(e) {e.preventDefault();} );

  $("#export :button").click( function() {
    var url="_list/export/geojson";
    url+="?filename="+$("#export [name='filename']").val();
    url+="&filetype="+$("#export [name='filetype']:checked").val();
    var documents=filters[filters.length-1].documents;
    var keys=[], id=null;
    // ignore geometry keys for xml
    var include_geometry=$("#export [name='filetype']:checked").val()!=="xml";
    for (var d=0;d<documents.length;d++) {
      var key=documents[d];
      if (include_geometry && id!==key[0]) keys.push([key[0],0]);
      keys.push(key);
      id=key[0];
    }
    if ($("#export [name='include-revision']").prop('checked'))
      url+="&include_revision";
    if ($("#export [name='include-geojson-id']").prop('checked'))
      url+="&include_geojson_id";
    if ($("#export [name='select-fields']:checked").val()==="from-table") {
      var fields=[];
      $("#table thead .field").each(function() { fields.push($(this).val()); });
      url+="&fields="+fields.join(':').replace(/\+/g,'%2B').replace(/\s/g,'%20');
    }
    var translate_url=({
      'download':function(url) { window.open(url+"&download", "_self"); },
      'get-url':function(url) {
        url=window.location.origin+'/'+list.db+'/_design/'+list.app+'/'+url;
        // hide download button
        $("#export [name='get-url']").hide();
        // display the url in a selected text input
        $("#export [name='url']").val(url).show().focus().select();
      }
    })[$(this).prop('name')];
    // Provide a permanent link if the URI is small.
    keys=JSON.stringify(keys);
    if (keys.length<=4096) {
      translate_url(url+"&keys="+keys);
      return;
    }
    // Otherwise employ index compression.
    $.getJSON("_view/geojson-doc", function(data) {
      // get document order identical to _view/geojson
      keys=data.rows;
      // Replace each key with its string representation,
      for (var k=0;k<keys.length;k++)
        keys[k]=JSON.stringify([keys[k].key, keys[k].id]);
      var list=[];
      // in order to get a valid result from Array.indexOf().
      for (var d=0;d<documents.length;d++)
        list.push(keys.indexOf(JSON.stringify(documents[d])));
      // Compute start_key and end_key to reduce amount of rows that
      // are JSON.parse'ed and then just skipped by _list/export.
      indexes.sort(list);
      var offset=list[0];
      var start_key='["'+JSON.parse(keys[offset])[0]+'",0]';
      var end_key=keys[list[list.length-1]];
      url+="&start_key="+start_key+"&end_key="+end_key;
      for (var i=0;i<list.length;i++) list[i]-=offset;
      translate_url(url+"&compressed_keys="+indexes.compress(list));
    });
  });

  // Hide url text input and display 'get-url' again.
  $("#export [name='url']").focusout( function() {
    $(this).hide();
    $("#export [name='get-url']").show();
  });

});
</script>

<style>
  #settings .geometry-level {width:6em}
  span {white-space:nowrap}
  .types {white-space:normal}
  #cuts li {display:inline}
  table, th, tr, td {
    padding:0; padding-right:3px;
    border-collapse:collapse;
    vertical-align:top
  }
  #table a:focus {font-weight:bold}
</style>

  </head>
  <body style="height:90%">

  <iframe src="login_bar.htm" style="width:100%; height:1.6em; border:0;"></iframe>

  <h1> Karte </h1>
  <form id="settings"> Darstellung:
    <input type="button" name="refine" class="geometry-level" value="verfeinern">
    <input type="button" name="precise" class="geometry-level" value="exakt" style="display:none">
    <input type="button" name="simplified" class="geometry-level" value="vereinfacht" style="display:none">
    <span><input type="checkbox" name="delayed">verzögert</span>
    <span><input type="text" name="limit" size=2 value="50"> Polygone</span>
    <span><input type="button" value="weniger" name="less">
      <input type="button" value="mehr" name="more"></span>
  </form>
  <div id="map" style="height:65%"></div>
  <form id="filter"> Filter:
    <span class="types"></span><br>
    <span>von: <input type="text" size=8 name="time" title="Zeit"></span>
    <span>enthält: <input type="text" size=24 name="content" title="Stichwort/Suchbegriff"></span>
    <span>als: <select name="field">
      <option value="_keyword">Text</option>
      <option value="_expression">Funktion</option>
      <optgroup name="fields" label="Felder"></optgroup>
    </select></span>
    <ol id="cuts">
      <!-- default filter list items -->
      <li style="display:none" id="type-is">
        <input type="button" value="x" title="löschen"> <a></a></li>
      <li style="display:none" id="time-is">
        <input type="button" value="x" title="löschen"> <b>Zeit:</b> <a></a></li>
      <li style="display:none" id="contains">
        <input type="button" value="x" title="löschen"> <b>enthält</b> <a></a></li>
      <li style="display:none" id="has-defined">
        <input type="button" value="x" title="löschen"> <b></b> zugewiesen</li>
      <li style="display:none" id="field-is">
        <input type="button" value="x" title="löschen"> <b></b> <a></a></li>
      <li style="display:none" id="expression">
        <input type="button" value="x" title="löschen"> <b>erfüllt</b> <a></a></li>
    </ol>
  </form>
  <table id="table">
    <thead><tr>
      <th class="geometry"></th>
      <th class="document">Beschreibung</th>
      <th><select name="field">
        <!-- unselect any column on page load -->
        <option selected style="display:none"></option>
        <optgroup name="fields" label="neue Spalte"></optgroup>
        <optgroup name="columns" label="Spalte löschen"></optgroup>
      </select></th>
    </tr></thead>
    <tbody></tbody>
  </table>
  <form id="export">
    <span>Auswahl als <input type="text" value="export" name="filename"></span>
    <span>
      <input type="radio" name="filetype" value="geojson" checked>.geojson
      <input type="radio" name="filetype" value="xml">.xml-Tabelle</span>
    <input type="button" value="speichern" name="download">
    <input type="button" value="URL erzeugen" name="get-url">
    <input type="text" name="url" style="display:none">
    <span>
      <input type="radio" name="select-fields" checked>alle
      <input type="radio" name="select-fields" value="from-table">ausgewählte Spalten</span>
    <span>
      <input type="checkbox" name="include-revision" checked>_id, _rev
      <input type="checkbox" name="include-geojson-id" checked>Geometrie-Schlüssel</span>
  </form>
  </body>
</html>
