<!DOCTYPE html>

<html lang="de" style="height:125%">
  <head>
    <title>Karte</title>
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8">
    <link href="css/jquery-ui-1.10.4.custom.css" rel="stylesheet">
    <script src="script/jquery-1.11.1.min.js"></script>
    <script src="script/jquery-ui-1.10.4.custom.js"></script>
    <script src="script/require.js"></script>
    <script type="text/javascript" src="https://maps.googleapis.com/maps/api/js?v=3.16&sensor=false"></script>
    <script src="script/google.maps.js"></script>
    <script src="script/fillColors.js"></script>

<script type="text/javascript">
$(document).ready(function() {

  var map = new Maps.Map($('#map')[0], {
    zoom: 12,
    mapTypeId: Maps.MapTypeId.SATELLITE,
    center: new LatLng(50.83730534254573, 13.938310197234163)
  });

  if (Maps.offline) {
    $("#map").hide();
    $("#offline-map").show();
    $("#settings").find(".geometry-level, [name=delayed]").prop('disabled', true);
  }

  var path=require('views/lib/path');
  var ranges=require('views/lib/ranges');
  var indexes=require('views/lib/indexes');

  // initialize map viewport
  $.getJSON("_view/dimensions", function(data) {
    var bbox=data.rows[0].value.bbox;
    map.setCenter(new LatLng((bbox[3]+bbox[1])/2.0, (bbox[2]+bbox[0])/2.0));
    // also initialize the time text field
    $("#filter [name=time]").val(ranges.toString(data.rows[0].value.ranges));
  });

  // get doc types and set colors
  $.getJSON("_view/type-year?group_level=1&descending=true", function(data) {
    while (data.rows.length) {
      var type=data.rows.pop().key.pop();
      var label=$('<label>').text(type)
                            .prepend( $('<input>').attr({type:"checkbox",name:type}) );
      $("#filter .types").append(label, ' ');
      filters[0].types.push(type);
      // This is one rare advantage of javascripts 'phony' arrays:
      // I can use fillColors first as a set and then assign keys
      // to each element!! How nice!!!
      fillColors[type] = fillColors[type] || fillColors.shift();
    }
  });

  // get doc fields
  $.getJSON("_view/field-type-value", {
    group_level:1, descending:true
  }, function(data) {
    var optgroup=$("[name=fields]");
    optgroup.append($("<option>").text("_id"));
    while (data.rows.length)
      optgroup.append($("<option>").text(data.rows.pop().key[0]));
  });

  // Initialize map position and geometry as soon as map has finished loading.
  Maps.event.addListenerOnce(map, 'tilesloaded', function() {
    // get list of GeoJSON keys, largest to smallest item
    $.getJSON("_view/dimensions?reduce=false&descending=true&end_key=0", function(data) {
      var geometries=[], rows=data.rows;
      while (rows.length)
        geometries.push(rows.pop().id);
      // get associated document ids
      $.post("_view/geojson-doc", JSON.stringify({keys:geometries}), function(data) {
        var documents=filters[0].documents;
        var rows=data.rows, row;
        while ( row=rows.pop() )
          documents.push([row.key, row.id]);
        filter_documents(filter_documents.commands);
        Maps.event.addListener(map, 'bounds_changed', call.this_one_next(update_items));
      }, "json");
    });
  });

  // POST or possibly GET _list/bbox-filter/<view>.
  function list(list, options, success) {
    var params={
      type:"get",
      dataType:"json",
      success:success,
      error:call.that_last_one
    };
    if (options.GeoJSON) {
      params.type="post";
      params.data=JSON.stringify({
        GeoJSON:options.GeoJSON,
        keys:options.keys
      });
      delete options.GeoJSON;
      delete options.keys;
      options=encodeURIComponent(JSON.stringify(options));
      $.ajax("_list/"+list+"?options="+options, params);
      return;
    }
    var keys=JSON.stringify(options.keys);
    delete options.keys;
    options=encodeURIComponent(JSON.stringify(options));
    if (keys.length>8192) {
      params.type="post";
      params.data='{"keys":'+keys+'}';
      $.ajax("_list/"+list+"?options="+options, params);
    } else $.ajax("_list/"+list+"?options="+options+"&keys="+keys, params);
  }
  // ok this also looks retarded but it keeps my stuff in one place at least
  list.parts=window.location.pathname.split('/');
  list.db=list.parts[1];
  list.app=list.parts[2]+'/'+list.parts[3];
  delete list.parts;

  // It is very likely that the oftentimes inexperienced user clicks and
  // scrolls the map like an ape (on adderall). Then, event handler callbacks
  // will be fired all over the place and the interface probably won't react
  // anymore. It should be smarter than that; It should wait a couple of
  // seconds, then wait for the last ajax to complete, then do the next thing
  // that needs to be done.
  var call={
    now:null, next:null,
    this_one_next:function(what) {
      // We might as well do the closure here, because this
      // is used only for event handler registration anyway.
      return function() {
        if (call.now!==null) call.next=what;
        else (call.now=what)();
      }
    },
    that_last_one:function() {
      window.setTimeout(function() {
        call.now=call.next;
        call.next=null;
        if (call.now!==null) call.now();
      }, 500);
    },
    no_one:function() {
      call.now=null;
      call.next=null;
    }
  };
  // All items that are displayed on the map are in here as "id":{etc.}.
  var items={};
  // This contains an ordered list of ALL GeoJSON keys.
  var keys=[];
  // This contains a cascading viewport array,
  // initialized to one default element.
  var viewports=[{
    bbox: [-Infinity,-Infinity,Infinity,Infinity],
    pad: [-Infinity,-Infinity,Infinity,Infinity],
    prefix: [], // (limited) items returned by this viewport
    position: 0 // index from which to append remaining keys
  }];
  // Same as viewports for content-based filters.
  var filters=[{ types:[], time:"", documents:[], union:[] }];
  // Document set used by update_items() below.
  update_items.documents=filters[0].documents;
  // Send filter commands to queue during initialization.
  filter_documents.commands=[];

  // query for GeoJSON and full documents
  function update_geometry() {
    var geometries=[], documents=[], old_items=[];
    for (var id in items) {
      var item=items[id];
      if (item.remove_me) {
        old_items.push(item);
        delete items[id];
        continue;
      }
      if (!item.keep_shape)
        geometries.push(item.keys[0]);
      if (!item.keep_documents)
        documents=documents.concat(item.keys.slice(1));
    }
    if (!geometries.length && !documents.length)
      return success({rows:[]});
    var successful=false;
    function ajax() {
      $.ajax("_view/geojson", {
        type:"POST",
        data:'{"keys":'+JSON.stringify(documents.concat(geometries))+'}',
        dataType:"json",
        success:success,
        complete:function() {
          // Sadly, this seems to be the only way to catch
          // CouchDB's internal server error or whatever this is.
          if (!successful)
            window.setTimeout(ajax, 50);
        }
      });
    }
    ajax();
    // Even more sad: I need to add this timer
    // because Chrome does not call 'complete'.
    window.setTimeout(function() { if (!successful) ajax(); }, 3000);
    function success(data) {
      successful=true;
      var rows=data.rows;
      geometries=geometries.length;
      documents=documents.length;
      var columns=[];
      $("#table thead .field").each(function() {
        columns.push({
          field:$(this).text(),
          path:path.decode($(this).text())
        });
      });
      var bull=$("#table thead .geometry span").html();
      var add_time = !!$("#table thead .title-time").length;
      var tbody=$(document.createDocumentFragment());
      var old_tbody=$();
      // timeout is 5ms or instantaneous
      var timeout = 5 * $("#settings [name=delayed]").prop('checked');
      var interval=window.setInterval( function() {
        while (old_items.length!==0) {
          var item=old_items.pop();
          old_tbody=old_tbody.add(item.tr);
          item.shape.setMap();
          if (timeout) return;
        }
        while (geometries!==0) {
          var row=rows.pop();
          var item=items[row.key[0]];
          var options=expand_options({ coordinates:row.value.GeoJSON.coordinates, map:map});
          if (item.shape==null) {
            item.shape=create_shape(row.value.GeoJSON.type, options);
            item.shape.addListener('click', update_geometry.highlight_row);
          } else item.shape.setOptions(options);
          geometries--;
          if (timeout) return;
        }
        window.clearInterval(interval);
        while (documents!==0) {
          var item=items[rows[rows.length-1].key[0]];
          var slice=rows.splice(1-item.keys.length);
          documents-=slice.length;
          var tr=$(document.createDocumentFragment());
          var td=$("<td>");
          td.html(bull).click(item, update_geometry.highlight_shape)
                       .addClass("geometry");
          tr.append(td);
          var td=$("<td>");
          for (var s=0;s<slice.length;s++) {
            var doc=slice[s].value.doc;
            var a=$("<a>");
            a.text( doc[doc.type]||doc.type )
             .one("mouseenter", update_geometry.show_document)
             .attr({
              href:"_show/edit/"+doc._id,
              target:"_blank", title:"..."
            });
            if (add_time && doc.time)
              a.append(' ('+doc.time+')');
            td.append(a, '<br>');
          }
          tr.append(td);
          for (var c=0, column; column=columns[c]; c++) {
            var td=$("<td>");
            for (var s=0;s<slice.length;s++) {
              var value=slice[s].value.doc;
              for (var p=0; value && p!==column.path.length; p++)
                value=value[column.path[p]];
              td.append(
                $("<span>").text(value)
                           .addClass('field')
                           .click({ field:column.field, value:value },
                                    update_geometry.create_filter), '<br>');
            }
            tr.append(td);
          }
          if (item.tr) item.tr.html('').append(tr);
          else tbody.append( item.tr=$("<tr>").append(tr) );
          var color=fillColors[slice[0].value.doc.type];
          if (item.shape.solid)
            item.shape.setOptions({fillColor:color});
          else item.shape.setOptions({strokeColor:color});
          item.keep_documents=true;
        }
        $("#table tbody").append(tbody);
        old_tbody.remove();
        call.that_last_one();
      }, timeout);
    }
  }

  update_geometry.show_document=function() {
    var a=$(this);
    $.getJSON('/'+list.db+a.attr('href').match(/\/[^/]+$/), function(doc) {
      delete doc.GeoJSON;
      a.attr('title', function stringify(obj, spaces, lines) {
        for (var prop in obj)
          if (obj[prop] && typeof obj[prop]==="object") {
            lines.push(spaces+prop+':');
            stringify(obj[prop], spaces+'  ', lines);
          } else lines.push(spaces+prop+': '+obj[prop]);
        return lines;
      }(doc, "", []).join('\n') );
    });
  };

  update_geometry.highlight_row=function() {
    this.setOptions({zIndex:-new Date().getTime()});
    for (var id in items) {
      var item=items[id];
      if (item.shape!==this) continue;
      // IE-10.0 loses this <a>'s focus because the map was clicked
      // once before. It works just fine if we delay it by 1ms.
      window.setTimeout(function() {
        $("#table tbody").prepend(item.tr);
        item.tr.find('a:first').focus();
      }, 1);
      return;
    }
  };

  update_geometry.highlight_shape=function(e) {
    var item=e.data;
    var bbox=item.GeoJSON.bbox;
    // Center map to the shape and highlight it.
    map.setCenter(new LatLng( (bbox[3]+bbox[1])/2.0, (bbox[2]+bbox[0])/2.0 ));
    item.shape.setOptions({strokeColor:"#FF0000", zIndex:new Date().getTime()});
    $("#table tbody").prepend(item.tr);
  };

  update_geometry.create_filter=function(e) {
    $("#filter [name=field]").val(e.data.field);
    var value=e.data.value.toString();
    value=JSON.stringify(value).slice(1,-1).replace(/\\"/g, '"');
    value='^'+value.replace(/[.*+?^=${}()|\[\]]/g, "\\$&")+'$';
    $("#filter [name=content]").val(value).keypress();
  };

  // diff-updates items inside viewport
  function update_items() {
    var NE=map.getBounds().getNorthEast();
    var SW=map.getBounds().getSouthWest();
    var options={
      limit:+$("#settings [name=limit]").val() || 1,
      error:$("#settings [name=simplified]:hidden").length &&
              +((NE.lat()-SW.lat())/100).toExponential(1),
      bbox:[ SW.lng(), SW.lat(), NE.lng(), NE.lat() ]
    };
    // get viewport that surrounds bbox
    var v=viewports.length, vp;
    do vp=viewports[--v];
    while (options.bbox[0]<vp.bbox[0]||options.bbox[1]<vp.bbox[1]||
           options.bbox[2]>vp.bbox[2]||options.bbox[3]>vp.bbox[3]);
    // if only one viewport was removed, it might be extended
    var extend_vp = v==viewports.length-2 && viewports[v+1];
    // do away with the unneeded viewports
    viewports.splice(v+1);
    // don't query for more geometries if pad lies inside bbox
    if (options.bbox[0]<=vp.pad[0]&&options.bbox[1]<=vp.pad[1]&&
        options.bbox[2]>=vp.pad[2]&&options.bbox[3]>=vp.pad[3]) {
      options.keys=vp.prefix;
      delete options.bbox;
      delete options.limit;
    } else if (!update_items.GeoCouch)
      // ignore items that were already dropped by previous viewport
      options.keys=vp.prefix.concat(keys.slice(vp.position));
    // Query GeoCouch spatial handler if installed,
    // but limit output to 1500 items (~300kb).
    if (update_items.GeoCouch && options.bbox) $.getJSON("_spatial/bbox", {
      count:true, bbox:options.bbox.toString()
    }, function(data) {
      var rows=data.rows;
      if (rows) {
        var ids={}, row;
        // hash each geometry id to true for faster look-up
        while ( row=rows.pop() ) ids[row.id]=true;
        var prefix=[];
        // fill keys intersected with ids into prefix
        for (var k=0, key; key=keys[k]; k++)
          if ( ids[key] && prefix.push(key)===options.limit )
            break;
        options.keys=prefix;
        delete options.bbox;
        delete options.limit;
        list("bbox-filter/bbox", options, success);
      } else if (data.count>1500) {
        options.keys=vp.prefix.concat(keys.slice(vp.position));
        list("bbox-filter/bbox", options, success);
      } else $.getJSON("_spatial/bbox", {
        bbox:options.bbox.toString()
      }, this.success);
    }); else list("bbox-filter/bbox", options, success);
    function success(data) {
      var documents=update_items.documents, position=0;
      for (var id in data) {
        var item=items[id], KEYS;
        if (item) {
          KEYS=item.keys;
          var error=data[id].GeoJSON.error;
          item.keep_shape = KEYS[0][1]===error;
          KEYS[0][1]=error;
        } else {
          item=items[id]=data[id];
          item.keys=KEYS=[[id, item.GeoJSON.error]];
          extend_vp.dismiss=true;
        }
        if (!item.keep_documents) {
          KEYS.splice(1);
          while (documents[position][0]!==id)
            position=(position+1)%documents.length;
          // add all associated documents
          while (position<documents.length && documents[position][0]===id)
            KEYS.push(documents[position++]);
        }
      }
      // stage out-of-viewport items for deletion
      for (var id in items) {
        if (id in data) continue;
        items[id].remove_me=true;
        extend_vp.dismiss=true;
      }
      // Fetch changed geometries in 50 ms.
      window.setTimeout(update_geometry, 50);
      if (!options.bbox) return;
      if (extend_vp && !extend_vp.dismiss) {
        if (options.bbox[0]<extend_vp.bbox[0]) extend_vp.bbox[0]=options.bbox[0];
        if (options.bbox[1]<extend_vp.bbox[1]) extend_vp.bbox[1]=options.bbox[1];
        if (options.bbox[2]>extend_vp.bbox[2]) extend_vp.bbox[2]=options.bbox[2];
        if (options.bbox[3]>extend_vp.bbox[3]) extend_vp.bbox[3]=options.bbox[3];
        viewports.push(extend_vp);
        return;
      }
      // prepare new viewport
      var new_vp={
        bbox:options.bbox, prefix:[],
        pad:[Infinity,Infinity,-Infinity,-Infinity],
      };
      // I need the last prop of data after the loop again. And
      // yes, I know it looks silly and it makes no difference.
      var id; for (id in data) {
        new_vp.prefix.push(id);
        var bbox=data[id].GeoJSON.bbox;
        if (bbox[2]<new_vp.pad[0]) new_vp.pad[0]=bbox[2];
        if (bbox[3]<new_vp.pad[1]) new_vp.pad[1]=bbox[3];
        if (bbox[0]>new_vp.pad[2]) new_vp.pad[2]=bbox[0];
        if (bbox[1]>new_vp.pad[3]) new_vp.pad[3]=bbox[1];
      }
      // It is safe to assume that any key before the last one
      // is either outside the viewport or already in prefix.
      new_vp.position=keys.indexOf(id)+1;
      viewports.push(new_vp);
    }
  }

  // Use GeoCouch if installed.
  $.getJSON("_spatial/_info", function() {
    update_items.GeoCouch=true;
  });

  // Applies new filter to document list; new_filter must be an object
  // denoting the filter type by its first member. It is then either
  // i) attached at the end of the filter queue
  // ii) inserted in the middle and merged with filters following it
  // iii) nothing of the above if an identical filter is already used.
  function filter_documents(new_filter) {
    var commands=filter_documents.commands;
    if (!commands) {
      // Set up a new command stack if none is in place yet.
      commands=Array.prototype.slice.apply(arguments, [1]);
      filter_documents.commands=commands;
      window.setTimeout(function() {
        if (!filter_documents.commands) return;
        var interval=window.setInterval(function() {
          var li=$("#cuts li.in-progress");
          li.last().hide();
          if (filter_documents.commands)
            $("#cuts").append(li.first().show());
          else window.clearInterval(interval);
        }, 250);
      }, 500);
    } else if (arguments[0]!==commands) {
      // If filters are already processed parallel to
      // this, push new filters to the command stack.
      Array.prototype.push.apply(commands, arguments);
      return;
      // filter_documents(filter_documents.commands) is
      // employed below to recurse to the next filter.
    } else new_filter=commands.shift();
    // If the command stack is depleted, reset
    // viewports, update geometries and etc.
    if (!new_filter) {
      delete filter_documents.commands;
      var documents=update_items.documents=filters[filters.length-1].documents;
      keys.splice(0);
      for (var d=0, id=null, doc; doc=documents[d]; d++)
        if (id!==doc[0]) keys.push(id=doc[0]);
      for (var id in items)
        items[id].keep_documents=false;
      viewports.splice(1);
      call.this_one_next(update_items)();
      return;
    }
    // Aquire first property as name of new_filter.
    var filter_name=function() {for (var prop in new_filter) return prop;}();
    // In any case, we can use the full, non-filtered document list.
    var documents=filters[0].documents;
    // Remind me if we already have an identical filter in place.
    var equal_filter=false;
    var position=0;
    // Fetch most-recent time and type for secondary index queries.
    var recent={};
    // Check what document list to reuse: As soon as a conflicting (that is
    // non-containing) filter is found, this one and every filter following it
    // need to be re-evaluated.
    while ( position<filters.length && function(filter) {
      recent.time = filter.time || recent.time;
      recent.types = filter.types || recent.types;
      // In this part we determine for each filter type if it
      // a) is more restrictive than an already applied filter, and
      // b) happens to be identical to said filter.
      // I have written this part using an anonymous function because it is
      // most concise and every attempt to do this without resulted in
      // additional clutter. Also I expect filters.length not to exceed 20.
      if (filter[filter_name]==null) return true;
      switch(filter_name) {
      case "union":
        filter.union=new_filter.union;
        // Tag document selection to bypass _list/tabulate.
        for (var d=0;d<filter.union.length;d++)
          filter.union[d].keep_me=true;
        if (filter.union.length) return true;
        // Remove the tag from each document if new_filter.union is empty.
        // Here I take advantage over the circumstance that, by the poor design
        // of my interface, new_filter.union is only shrinking to an empty set.
        for (var d=0;d<documents.length;d++)
          delete documents[d].keep_me;
        // Here I cause the remaining filters to collapse into filters[1],
        // because I want to leave the top-level filter untouched.
        position++;
        return false;
      case "spatial":
        return new_filter.spatial;
      case "time":
        var contains=(ranges.contains(filter.time, new_filter.time));
        if (contains) equal_filter=(ranges.contains(new_filter.time, filter.time));
        return contains;
      case "types":
        var contains=(new_filter.types.length<=filter.types.length);
        for (var t=0; contains && t<new_filter.types.length; t++)
          contains &= (filter.types.indexOf(new_filter.types[t])!==-1);
        if (contains) equal_filter=(new_filter.types.length===filter.types.length);
        return contains;
      case "cuts":
        var cut=new_filter.cuts[0];
        if (!cut.remove_me) return true;
        var index=filter.cuts.indexOf(cut);
        if (index===-1) return true;
        filter.cuts.splice(index,1);
        delete new_filter.cuts;
        return false;
      }
    }(filters[position]) )
      // If the last filter was compatible, we can use its document list.
      documents=filters[position++].documents;
    filters.push(new_filter);
    // Divert spatial filters to the request chain below.
    if (new_filter.spatial) {
      var passed=new_filter.passed || function(keys) {
        var result={};
        new_filter.data='{"keys":[["'+keys.join('",0],["')+'",0]]}';
        while (keys.length) result[keys.pop()]=true;
        delete new_filter.keys;
        return result;
      }(new_filter.keys);
      $.post("_view/geojson", new_filter.data, function(data) {
        var GeometryCollection={ type:"GeometryCollection", geometries:[] };
        var bbox=[Infinity,Infinity,-Infinity,-Infinity];
        while (data.rows.length) {
          var GeoJSON=data.rows.pop().value.GeoJSON;
          var bbox2=GeoJSON.bbox;
          bbox[0]=(bbox[0]<bbox2[0]?bbox:bbox2)[0];
          bbox[1]=(bbox[1]<bbox2[1]?bbox:bbox2)[1];
          bbox[2]=(bbox[2]>bbox2[2]?bbox:bbox2)[2];
          bbox[3]=(bbox[3]>bbox2[3]?bbox:bbox2)[3];
          GeometryCollection.geometries.push({
            type:GeoJSON.type, coordinates:GeoJSON.coordinates
          });
        }
        var ids=[];
        for (var d=0, doc, id=null; doc=documents[d]; d++) {
          if (id===doc[0]) continue;
          if (passed[id=doc[0]]===undefined) ids.push(id);
        }
        var options={keys:ids, bbox:bbox, relation:new_filter.spatial};
        // Query GeoCouch spatial handler if available.
        if (update_items.GeoCouch) $.getJSON("_spatial/bbox", {
          bbox:options.bbox.toString()
        }, function(data) {
          // Hash geometry ids to true.
          var row, rows=data.rows, intersects={};
          while ( row=rows.pop() )
            intersects[row.id]=true;
          // Intersect options.keys with hashed geometry ids.
          options.keys=[];
          for (var i=0, id; id=ids[i]; i++)
            if (intersects[id]) options.keys.push(id);
          list("bbox-filter/bbox", options, success);
        }); else list("bbox-filter/bbox", options, success);
        function success(data) {
          options.keys=[];
          for (var id in data) options.keys.push([id,0]);
          options.GeoJSON=GeometryCollection;
          delete options.bbox;
          list("bbox-filter/geojson", options, function(data) {
            var new_documents=[];
            while (ids.length) {
              var id=ids.pop();
              passed[id]=id in data;
            }
            for (var d=0, doc; doc=documents[d]; d++)
              if (passed[doc[0]]) new_documents.push(doc);
            new_filter.documents=new_documents;
            new_filter.passed=passed;
            filter_documents(commands);
          });
        };
      }, "json");
      return;
    }
    // Collapse remaining filters into options.
    var options={cuts:[]};
    for (var filter; filter=filters.splice(position,1)[0]; ) {
      if ('time' in filter) options.time=filter.time;
      if ('types' in filter) options.types=filter.types;
      if ('cuts' in filter) options.cuts=options.cuts.concat(filter.cuts);
      // Issue spatial to be applied when the other filters are done.
      if (new_filter.spatial===false) continue;
      if ('spatial' in filter) commands.push(filter);
    }
    // Remove options.cuts array if empty.
    if (!options.cuts.length) delete options.cuts;
    // Remove filter from options if an identical one has already been applied.
    if (equal_filter) delete options[filter_name];
    // Avoid query if all filters have been removed from options.
    if (!function() { for (var prop in options) return true; }())
      return filter_documents(commands);
    // Pre-filter documents with indexed type and year.
    if ( (options.types || options.time) && documents.length>500 ) {
      var types=options.types || recent.types;
      var time=options.time || recent.time;
      $.getJSON("_view/type-year", {
        group:true,
        start_key:JSON.stringify([types[0]]),
        end_key:JSON.stringify([types[types.length-1], {}])
      }, function(data) {
        var rows=data.rows, row, list_keys=[], view_keys=[];
        while ( row=rows.pop() ) {
          if (types.indexOf(row.key[0])===-1) continue;
          // Ignore isolated time intervals.
          if (!ranges.intersects(time, row.value.one)) continue;
          // 'all' is within every doc.time and therefore any interval
          // that intersects with it intersects with every doc.time.
          if ( ranges.intersects(time, row.value.all) ||
          // 'one' covers every doc.time, so if time
          // contains it, it intersects every doc.time.
               ranges.contains(time, row.value.one) )
            view_keys.push(row.key);
          else list_keys.push(row.key);
        }
        $.getJSON("_list/tabulate/type-year", {
          reduce:false, keys:JSON.stringify(list_keys),
          options:JSON.stringify({ time:time })
        }, function(list_ids) {
          $.getJSON("_view/type-year", {
            reduce:false, keys:JSON.stringify(view_keys)
          }, function(view_data) {
            var doc_ids={};
            // Hash doc ids from _view/type-year.
            while (view_data.rows.length)
              doc_ids[view_data.rows.pop().id]=true;
            // Hash doc ids from _list/tabulate/type-year.
            while (list_ids.length)
              doc_ids[list_ids.pop()]=true;
            var new_documents=[];
            for (var d=0, doc; doc=documents[d]; d++)
              if (doc.keep_me || doc[1] in doc_ids)
                new_documents.push(doc);
            filters.push(new_filter={ documents:new_documents });
            if (options.time) new_filter.time=options.time;
            if (options.types) new_filter.types=options.types;
            delete options.types;
            delete options.time;
            if (function() { for (var prop in options) return true; }())
              commands.unshift(options);
            filter_documents(commands);
          });
        })
      });
      return;
    }
    // Pre-filter documents with indexed document field and value.
    if ( options.cuts && documents.length > 500 && function() {
      // Find a cut that neither an _expression nor a _keyword.
      var cut;
      for (var c=0; cut=options.cuts[c]; c++)
        if (!/^_(id|expression|keyword)$/.test(cut.field))
          break;
      if (!cut) return false;
      var types=options.types || recent.types;
      // Update filter queue with the view result.
      function success(data) {
        var doc_ids={};
        while (data.rows.length)
          doc_ids[data.rows.pop().id]=true;
        var new_documents=[];
        for (var d=0, doc; doc=documents[d]; d++)
          if (doc.keep_me || doc[1] in doc_ids)
            new_documents.push(doc);
        filters.push(new_filter={ documents:new_documents, cuts:[cut] });
        options.cuts.splice(options.cuts.indexOf(cut), 1);
        if (!options.cuts.length) delete options.cuts;
        if (options.types) new_filter.types=options.types;
        delete options.types;
        if (function() { for (var prop in options) return true; }())
          commands.unshift(options);
        filter_documents(commands);
      }
      var values=".";
      // Multiple keys: /^(<KEY1>|...)>$/.
      if (/^\^\(.*\)\$$/.test(cut.value))
        values=cut.value.slice(2,-2).match(/(\\\||[^|])+/g);
      // Single key: /^<NO SPECIAL REGEXP SYMBOLS>$/.
      else if (/^\^.*\$$/.test(cut.value))
        values=[cut.value.slice(1,-1)];
      // Make sure that no special regexp symbols were
      // used and that values was prepared in a way.
      if (/^(\\[^sSwWdD]|[^\\(){}\[\]^$.*+?])*$/.test(values)) {
        for (var v=values.length-1; v!==-1; v--) {
          // Evaluate \n to newline and \( to (.
          values[v]=eval('"'+values[v].replace(/"/g,'\\"')+'"');
          // If value happens to be "true", "12,3" or something, it might
          // be indexed as JSON true or 12.3, because the type info gets
          // pretty much lost in all the HTML forms and whatnot.
          try { values.push(JSON.parse(values[v])); } catch(err) {};
        }
        var keys=[];
        for (var t=0; t<types.length; t++)
        for (var v=0; v<values.length; v++)
          keys.push([cut.field, types[t], values[v]]);
        $.getJSON("_view/field-type-value", {
          reduce:false, keys:JSON.stringify(keys)
        }, success);
        return true;
      }
      // Extract type intervals.
      var ranges=[];
      for (var t=0, key={}; t!==filters[0].types.length+1; t++) {
        var type=types[types.indexOf(filters[0].types[t])];
        key.start=key.start || type;
        key.end=type || key.end;
        if (type || !key.start || !key.end) continue;
        ranges.push({start_key:[cut.field, key.start, null], end_key:[cut.field, key.end, {}]});
        key.start=key.end=undefined;
      }
      var length=ranges.length, range, keys=[], rows=keys;
      if (cut.value) while ( range=ranges.pop() )
        $.getJSON("_list/tabulate/field-type-value", {
          start_key:JSON.stringify(range.start_key),
          end_key:JSON.stringify(range.end_key),
          group:true, options:JSON.stringify({
            cuts:[{field:"'"+cut.field+"'", value:cut.value}]
          })
        }, function(data) {
          Array.prototype.push.apply(keys, data);
          if (--length===0) $.getJSON("_view/field-type-value", {
            reduce:false, keys:JSON.stringify(keys)
          }, success);
        });
      else while ( range=ranges.pop() )
        $.getJSON("_view/field-type-value", {
          reduce:false,
          start_key:JSON.stringify(range.start_key),
          end_key:JSON.stringify(range.end_key)
        }, function(data) {
          Array.prototype.push.apply(rows, data.rows);
          if (--length===0) success({rows:rows});
        });
      return true;
    }()) return;
    options.keys=[];
    for (var d=0, doc; doc=documents[d]; d++)
      if (!doc.keep_me) options.keys.push(doc);
    list("tabulate/geojson", options, function(data) {
      var new_documents=[];
      var doc_id=data.reverse().pop();
      for (var d=0;d<documents.length;d++) {
        var doc=documents[d];
        if (doc[1]===doc_id) {
          doc_id=data.pop();
          new_documents.push(doc);
        } else if (doc.keep_me)
          new_documents.push(doc);
      }
      options.documents=new_documents;
      filters.push(options);
      filter_documents(commands);
    });
  }

  // Refine document list if date has changed.
  $("#filter [name=time]").keypress( function(e) {
    if (e.originalEvent && e.which!==13) return;
    var time=$(this).val();
    filter_documents({ time:time });
    var li=$("#time-is");
    // This way the filter shows up at the end of the list instead of at
    // the beginning. It is completely useless but I certainly like it.
    if (li.css("display")==="none")
      $("#cuts").append(li.show());
    li.find('a').text($(this).val());
    if (!time) li.hide();
  });

  // Remove document time constraint.
  $("#time-is :button").click(function() {
    filter_documents({ time:"" });
    $("#filter [name=time]").val('');
    $("#time-is").hide();
  });

  // Refine document list if types have changed.
  $("#filter .types").change( function() {
    var types=[];
    $("#filter .types :checked").each(function() {
      types.push($(this).prop('name'));
    });
    // If no types are selected we might as well select all of
    // them, because no-one really wants to see an empty list.
    if (!types.length) types=filters[0].types;
    // Update the list of fields to show only those
    // that are available by the given type selection.
    $.getJSON("_list/tabulate/field-type-value", {
      group_level:2, descending:true,
      options:JSON.stringify({types:types})
    }, function(keys) {
      var fields={_id:null};
      for (var t=0;t<types.length;t++)
        fields[types[t]]=null;
      while (keys.length)
        fields[keys.pop()[0]]=null;
      var optgroup=$("#filter [name=fields]");
      var val=$("#filter [name=field]").val();
      $("[name=fields]").html('');
      for (var field in fields)
        optgroup.append($("<option>").text(field));
      // The selected option was destroyed three lines above, so I just
      // re-select it here, and update the autocomplete source array.
      $("#filter [name=field]").val(val).change();
      // Remove fields that are in the 'columns' <optgroup> already.
      $("#table [name=columns] option").each( function() {
        delete fields[$(this).val()];
      });
      // Fill 'fields' optgroup with reduced set of fields.
      var optgroup=$("#table [name=fields]");
      for (var field in fields)
        optgroup.append($('<option>').text(field));
    });
    filter_documents({ types:types });
    // It sure would be nice to see the new filter appear
    // in the list, and I am in a good mood right now.
    var li=$("#type-is");
    li.find('a').text(types.join('/'));
    // append filter item at the end instead of inserting it
    if (li.css("display")==="none")
      $("#cuts").append(li.show());
    // hide filter item if it displays every type anyway
    if (types.length===filters[0].types.length)
      li.hide();
  });

  // Remove document type restriction.
  $("#type-is :button").click( function() {
    $("#filter .types :checked").prop('checked', false);
    $("#filter .types").change();
  });

  // Add content-filter on <enter> key press.
  $("#filter [name=content]").keypress( function(e) {
    if (e.originalEvent && e.which!==13) return;
    var cut={
      field:$("#filter [name=field]").val(),
      value:$(this).val().replace(/^\s+|\s+$/g,'') || undefined
    };
    // I've made template filter items at the bottom of the
    // page for the following field/value combinations.
    var id=function(field, value) {
      if (field==="_keyword" && value) return "#contains";
      if (field==="_expression" && value) return "#expression";
      if (field && value) return "#field-is";
      if (field[0]!=='_') return "#has-defined";
    }(cut.field, cut.value);
    if (!id) return;
    filter_documents({ cuts:[cut] });
    var li=$(id).clone();
    li.filter("#field-is, #has-defined").find('b').text(cut.field);
    li.append(cut.value).css('display','inline').prop('id',"");
    $("#cuts").append(li);
    li.find(':button').click(function() {
      // Tell filter_documents() to remove cut from the queue and set form
      // fields to its parameters; it is likely that the filter had a
      // spelling error, so I should provide an easy way to correct it.
      $("#filter [name=field]").val( cut.field ).change();
      $("#filter [name=content]").val( cut.value || "" );
      cut.remove_me=true;
      filter_documents({ cuts:[cut] });
      li.remove();
    });
    $("#cuts").append(li);
  });

  // Show or Hide #keep-selection.
  $("#cuts").click( function() {
    var ol=$(this);
    var li=$("#keep-selection");
    if (ol.find(".filter-item:visible").length)
      ol.append(li.show());
    else li.hide();
  });
  $("#filter .types").change( function() { $("#cuts").click(); });
  $("#filter").keypress( function(e) {
    if (!e.originalEvent || e.which===13)
      $("#cuts").click();
  });

  // Add filtered document to #union filter item and copy the filter list into
  // it; this serves neatly as a description of with which documents the union
  // is constructed.
  $("#keep-selection :button").click( function() {
    var union=$("#union");
    var span=union.find("span");
    if (union.css('display')!=='none')
      span.append(' <b>&cup;</b> ');
    $("#cuts > [id!=keep-selection][id!=union]:visible").each( function() {
      var li=$("<li>").html($(this).html());
      li.find(":button").remove();
      span.append(li.html());
    });
    $("#cuts").prepend(union.css('display', 'block'));
    $("#cuts > [id^=spatial-]").hide();
    filter_documents( {union:filters[filters.length-1].documents}, {spatial:false} );
  });

  // Discard stored selection and hide #union filter item.
  $("#discard-selection").click( function() {
    // also clear selection summary
    $("#union").hide().find("span").html('');
    filter_documents({ union:[] });
  });

  // Filter geometry by spatial relation.
  $("#union  [name]").click( function() {
    var relation=$(this).prop('name');
    var keys=[], documents=filters[0].union;
    for (var d=0, id=null; d<documents.length; d++)
      if (id!==documents[d][0])
        keys.push(id=documents[d][0]);
    var union=$("#union");
    // copy filter description into geometry filter item
    var li=$("#spatial-"+relation).css('display', 'block')
                                  .find("span")
                                  .html(union.find("span").html());
    union.hide().find("span").html('');
    filter_documents( {union:[]}, {spatial:relation, keys:keys} );
  });

  // Remove spatial filter.
  $("#cuts > [id^=spatial-] :button").click( function() {
    filter_documents({ spatial:false });
    $("#cuts > [id^=spatial-]").hide();
  });

  // Clear text input on field change.
  $("#filter [name=field]").change( function(e) {
    if (e.originalEvent)
      $("#filter [name=content]").val('');
  });

  // Update autocomplete source array.
  $("#filter [name=field]").change( function() {
    var input=$("#filter [name=content]");
    var field=$(this).val();
    if (!$(this).find("[name=fields] :selected").length) {
      input.autocomplete({source:[]});
      return;
    }
    var types=$("#filter .types :checked");
    if (!types.length) types=$("#filter .types :checkbox");
    // Hash each label to null.
    var labels={};
    // Set-up autocomplete to match the text input's value
    // as regular expression against a list of suggestions.
    function source(request, response) {
      var data=[];
      var matcher=new RegExp(request.term, "i");
      for (var label in labels) {
        label=label.substr(1);
        if (!matcher.test(label)) continue;
        var value=label;
        value=JSON.stringify(value).slice(1,-1).replace(/\\"/g, '"');
        value='^'+value.replace(/[.*+?^=${}()|\[\]]/g, "\\$&")+'$';
        data.push({ label:label, value:value });
        if (data.length===50) break;
      }
      // Provide a compiled key set as an autocomplete item. It
      // list all the other suggestions as /$(<VALUE1>|...)^/.
      if (request.term && data.length>1 && data.length<50) {
        var item={ label:input.data('use-suggestions') };
        item.value=[];
        for (var i=0;i<data.length;i++)
          item.value.push(data[i].value.slice(1,-1));
        item.value='^('+item.value.join('|')+')$';
        data.unshift(item);
      }
      response(data);
    }
    input.autocomplete({ minLength:0, source:source });
    types.each(function() {
      var type=$(this).prop('name');
      var params={
        limit:100, group:true, inclusive_end:false,
        start_key:JSON.stringify([field, type, ""]),
        end_key:JSON.stringify([field, type, []])
      };
      $.getJSON("_view/field-type-value", params, function(data) {
        var rows=data.rows;
        // If 100 rows or more are encountered, it is usually faster to proceed
        // with ungrouped rows and let the browser reduce to unique values.
        if (rows.length===params.limit) {
          params.start_key=JSON.stringify(rows.pop().key);
          delete params.group;
          params.reduce=false;
          params.limit=2000;
          $.getJSON("_view/field-type-value", params, this.success);
        }
        for (var r=0;r<rows.length;r++)
          labels[ '_'+data.rows[r].key[2] ]=null;
        // Update suggestions on each new chunk.
        if (input.is(":focus"))
          input.autocomplete("search", input.val());
      });
    });
  });

  // Add or remove column to #table.
  $("#table [name=field]").change( function() {
    var select=$(this);
    // Get selected option and find out in wich <optgroup> it belongs.
    var option=select.find(":selected");
    if (select.find("[name=columns] :selected").length) {
      // remove th from #table
      $("#table thead .field").each( function() {
        var th=$(this);
        if (th.text()!==option.val()) return;
        th.remove();
        return false;
      });
      // move option back to the fields optgroup
      select.find("[name=fields]").prepend(option);
    } else {
      var last=$("#table thead th:last");
      var th=$('<th>').text(option.val())
                      .addClass("field")
                      .click( function() { select.val($(this).text()).change(); });
      th.html(path.pretty(th.html(), '<br>'));
      // append new header and move column selection to the right
      $("#table thead tr").append(th, last);
      // move option to the columns optgroup
      select.find("[name=columns]").append(option);
    }
    // unselect column
    select.val('');
    for (var id in items) {
      items[id].keep_documents=false;
      items[id].keep_shape=true;
    }
    call.this_one_next(update_geometry)();
  });

  // Toggle document time.
  $("#table th.title-time").click( function() {
    var th=$(this);
    var cl=th.prop('class');
    th.removeClass(cl);
    if (cl==="title") th.addClass("title-time");
    if (cl==="title-time") th.addClass("title");
    for (var id in items) {
      items[id].keep_documents=false;
      items[id].keep_shape=true;
    }
    call.this_one_next(update_geometry)();
  });

  // cycle through geometric detail mode:
  // 'refine' <-> 'precise' -> 'simplified' -> 'refine'
  $("#settings [name=refine]").click( function() {
    $("#settings [name=refine]").hide();
    $("#settings [name=precise]").show();
    // show refined geometry once, and
    for (var id in items) {
      items[id].keep_shape=(items[id].keys[0][1]===0);
      items[id].keys[0][1]=0;
    }
    call.this_one_next(update_geometry)();
    // revert to 'refine', if viewport was moved
    Maps.event.addListenerOnce(map, 'bounds_changed', function() {
      // abort in case [name=precise] was already clicked
      if ($("#settings [name=simplified]").is(":visible")) return;
      $("#settings [name=precise]").hide();
      $("#settings [name=refine]").show();
    });
  });

  $("#settings [name=precise]").click( function() {
    $("#settings [name=precise]").hide();
    $("#settings [name=simplified]").show();
  });

  $("#settings [name=simplified]").click( function() {
    $("#settings [name=simplified]").hide();
    $("#settings [name=refine]").show();
    Maps.event.trigger(map, 'bounds_changed');
  });

  // increase limit to next higher [1,2,5,10,20,50,etc]
  $("#settings [name=more]").click( function() {
    var limit=$("#settings [name=limit]").val();
    var new_limit=10;
    while (new_limit<=limit) new_limit*=10;
    if (new_limit>5*limit) new_limit/=5;
    if (new_limit>2*limit) new_limit/=2;
    $("#settings [name=limit]").val(new_limit).change();
  });

  // decrease limit to next lower [1,2,5,10,20,50,etc]
  $("#settings [name=less]").click( function() {
    var limit=$("#settings [name=limit]").val();
    var new_limit=1;
    while (new_limit*10<limit) new_limit*=10;
    if (new_limit*5<limit) new_limit*=5;
    if (new_limit*2<limit) new_limit*=2;
    $("#settings [name=limit]").val(new_limit).change();
  });

  $("#settings [name=limit]").change( call.this_one_next( function() {
    var pad=viewports[0].pad;
    for (var v=1; v<viewports.length; v++)
      viewports[v].pad=pad;
    update_items();
  }));

  // Suppress page reload if uses hits enter in a text input.
  $("form").submit( function(e) {e.preventDefault();} );

  $("#export").find("[name=download], [name=get-url]").click( function() {
    var url="_list/export/geojson";
    url+="?filename="+$("#export [name=filename]").val();
    url+="&filetype="+$("#export [name=filetype]:checked").val();
    var documents=filters[filters.length-1].documents;
    var keys=[], id=null;
    // ignore geometry keys for xml
    var include_geometry=$("#export [name=filetype]:checked").val()!=="xml";
    for (var d=0;d<documents.length;d++) {
      var key=documents[d];
      if (include_geometry && id!==key[0]) keys.push([key[0],0]);
      keys.push(key);
      id=key[0];
    }
    if ($("#export [name=include-revision]").prop('checked'))
      url+="&include_revision";
    if ($("#export [name=include-geojson-id]").prop('checked'))
      url+="&include_geojson_id";
    if ($("#export [name=select-fields]:checked").val()==="from-table") {
      var fields=[];
      $("#table thead .field").each(function() { fields.push($(this).text()); });
      url+="&fields="+fields.join(':').replace(/\+/g,'%2B').replace(/\s/g,'%20');
    }
    var translate_url=({
      'download':function(url) { window.open(url+"&download", "_self"); },
      'get-url':function(url) {
        url=window.location.origin+'/'+list.db+'/'+list.app+'/'+url;
        // hide download button
        $("#export [name=get-url]").hide();
        // display the url in a selected text input
        $("#export [name=url]").val(url).show().focus().select();
      }
    })[$(this).prop('name')];
    keys=JSON.stringify(keys);
    // Employ index compression if the URL is too large.
    if (keys.length>8192) $.getJSON("_view/geojson-doc", function(data) {
      // get document order identical to _view/geojson
      var rows=data.rows;
      for (var k=0;k<rows.length;k++)
        rows[ [rows[k].key,rows[k].id] ] = k;
      var list=[];
      for (var d=0;d<documents.length;d++)
        list.push(rows[ documents[d] ]);
      // Compute start_key and end_key to reduce amount of rows that
      // are JSON.parse'ed and then just skipped by _list/export.
      indexes.sort(list);
      var offset=list[0];
      while (offset && rows[offset].key===rows[offset-1].key)
        offset--;
      url+="&start_key="+JSON.stringify([rows[offset].key, 0]);
      var end_row=rows[list[list.length-1]];
      url+="&end_key="+JSON.stringify([end_row.key, end_row.id]);
      for (var i=0;i<list.length;i++) list[i]-=offset;
      translate_url(url+"&compressed_keys="+indexes.compress(list));
    }); else
    // Otherwise provide a permant link.
      translate_url(url+"&keys="+keys);
  });

  // Hide url text input and display 'get-url' again.
  $("#export [name=url]").focusout( function() {
    $(this).hide();
    $("#export [name=get-url]").show();
  });

  $("#export [name=filetype]").change( function() {
    var elements=$("#export").find("[name=columns], [name=download], [name=get-url]");
    if ($(this).val()==="couchdb") {
      elements.hide();
      $("#export [name^=replicate]").show();
      $.getJSON("/_all_dbs", function(dbs) {
        // remove _special dbs and own from suggestion list
        for (var d=0;d<dbs.length;d++)
          if (dbs[d]===list.db || dbs[d][0]==="_") dbs.splice(d--,1);
        $("#export [name=filename]").autocomplete({
          source:dbs, minLength:0,
          position:{my:"left bottom", at:"left top"}
        });
      });
    } else {
      elements.show();
      $("#export [name^=replicate]").hide();
      $("#export [name=filename]").autocomplete({source:[]});
    }
  });

  $("#export [name=replicate]").click( function() {
    $(this).prop('disabled', true);
    $.post("_view/geojson-doc", JSON.stringify({keys:keys}), function(data) {
      var replication={
        source:list.db, create_target:true,
        target:$("#export [name=filename]").val(),
        doc_ids:[list.app]
      };
      while (data.rows.length)
        replication.doc_ids.push(data.rows.pop().id);
      var complete=function(jqXHR, textStatus) {
        // retry target prefixed with http:// if it looks like smith.iriscouch.com/db
        if ( textStatus!=="success" && replication.target.match('/') && !/^https?:/.test(replication.target) ) {
          $("#export [name=filename]").val(replication.target="http://"+replication.target);
          this.data=JSON.stringify(replication);
          $.ajax("/_replicate", this);
          return;
        }
        var resp=jqXHR.responseJSON || {status:textStatus};
        var lines=[];
        for (var prop in resp) {
          if (typeof resp[prop] === "object") continue;
          if (typeof resp[prop] === "function") continue;
          lines.push(prop+': <b>'+resp[prop]+'</b>');
        }
        $("#export [name=replicate-status]").html(lines.join(',<br>'));
        $("#export [name=replicate]").prop('disabled', false);
        if (textStatus!=="success") return;
        $("#export [name=replicate]").hide();
        var href=replication.target+'/'+list.app+"/index.html";
        if (!/^https?:/.test(replication.target)) href="../../../"+href;
        $("#export [name=replicant]").attr({ href:href }).show().focus();
      }
      $.ajax("/_replicate", {
        type:"POST", dataType:"json",
        contentType:"application/json",
        data:JSON.stringify(replication),
        complete:complete
      });
    }, "json");
  });

  // Hide db link and display 'replicate' again.
  $("#export [name=replicant]").focusout( function() {
    $(this).hide();
    $("#export [name=replicate]").show();
  });

  $("#export [name=filename]").keypress( function(e) {
    if (e.which!==13) return;
    $("#export [name=download]:visible").click();
    $("#export [name=replicate]:visible").click();
  });

});
</script>

<style>
  #settings .geometry-level {width:6em}
  label, span.nowrap {white-space:nowrap}
  #cuts li {display:inline}
  #cuts li.in-progress {
    font-weight:bold;
    font-family:monospace
  }
  table, th, tr, td {
    padding:0; padding-right:3px;
    border-collapse:collapse;
    vertical-align:top
  }
  #table a:focus {font-weight:bold}
  #table a {display:inline-block}
  #table td.geometry:hover,
  #table th.field:hover,
  #table th.title:hover,
  #table th.title-time:hover,
  #table td span.field:hover {cursor:pointer}
  #table .geometry {font-weight:900}
</style>

  </head>
  <body style="height:90%">

  <iframe src="login_bar.htm" style="width:100%; height:1.6em; border:0;"></iframe>

  <h1> Karte </h1>
  <form id="settings"> Darstellung:
    <input type="button" name="refine" class="geometry-level" value="verfeinern">
    <input type="button" name="precise" class="geometry-level" value="exakt" style="display:none">
    <input type="button" name="simplified" class="geometry-level" value="vereinfacht" style="display:none">
    <label><input type="checkbox" name="delayed">verzögert</label>
    <label><input type="text" name="limit" size=2 value="50"> Polygone</label>
    <span class="nowrap">
      <input type="button" value="weniger" name="less">
      <input type="button" value="mehr" name="more"></span>
  </form>
  <div id="map" style="height:65%"></div>
  <div id="offline-map" style="text-align:center;display:none">
    Offline-Karte: Google Maps API konnte nicht geladen werden.
    Diese wird zur Anzeige der Kartendaten benötigt.
  </div>
  <form id="filter"> Filter:
    <span class="types"></span><br>
    <label>von: <input type="text" size=8 name="time" title="Zeit"></label>
    <label>enthält: <input type="text" size=24 name="content" title="Stichwort/Suchbegriff"
                           data-use-suggestions="&lt;alle Vorschläge verwenden&gt;"></label>
    <label>als: <select name="field">
      <option value="_keyword">Text</option>
      <option value="_expression">Funktion</option>
      <optgroup name="fields" label="Felder"></optgroup>
    </select></label>
    <ol id="cuts">
      <!-- cycle through these if filter is busy -->
      <li style="display:none" class="in-progress">[-]</li>
      <li style="display:none" class="in-progress">[\]</li>
      <li style="display:none" class="in-progress">[|]</li>
      <li style="display:none" class="in-progress">[/]</li>
      <!-- default filter list items -->
      <li style="display:none" class="filter-item" id="type-is">
        <input type="button" value="x" title="löschen"> <a></a></li>
      <li style="display:none" class="filter-item" id="time-is">
        <input type="button" value="x" title="löschen"> <b>Zeit:</b> <a></a></li>
      <li style="display:none" class="filter-item" id="contains">
        <input type="button" value="x" title="löschen"> <b>enthält</b> </li>
      <li style="display:none" class="filter-item" id="has-defined">
        <input type="button" value="x" title="löschen"> <b></b> zugewiesen</li>
      <li style="display:none" class="filter-item" id="field-is">
        <input type="button" value="x" title="löschen"> <b></b> </li>
      <li style="display:none" class="filter-item" id="expression">
        <input type="button" value="x" title="löschen"> <b>erfüllt</b> </li>
      <!-- always show selected docs -->
      <li style="display:none" id="keep-selection">
        <input type="button" value="Auswahl merken"></li>
      <!-- union with stored selection -->
      <li style="display:none" id="union">
        <input type="button" value="x" title="löschen" id="discard-selection">
        <b>Auswahl:</b> <span></span><br>
        <input type="button" value="umgibt" name="contains">
        <input type="button" value="schneidet" name="intersects">
        <input type="button" value="innerhalb" name="within">
      </li>
      <!-- stored selection related to active selection -->
      <li style="display:none" id="spatial-contains">
        <input type="button" value="x" title="löschen">
        <span></span> <b>umgibt:</b> </li>
      <li style="display:none" id="spatial-intersects">
        <input type="button" value="x" title="löschen">
        <span></span> <b>überschneidet sich mit:</b> </li>
      <li style="display:none" id="spatial-within">
        <input type="button" value="x" title="löschen">
        <span></span> <b>befindet sich innerhalb:</b> </li>
    </ol>
  </form>
  <table id="table">
    <thead><tr>
      <!-- link to highlight geometry in the map canvas -->
      <th class="geometry"><span style="display:none">&bull;</span></th>
      <th class="title-time">Beschreibung</th>
      <th><select name="field">
        <!-- unselect any column on page load -->
        <option selected style="display:none"></option>
        <optgroup name="fields" label="neue Spalte"></optgroup>
        <optgroup name="columns" label="Spalte löschen"></optgroup>
      </select></th>
    </tr></thead>
    <tbody></tbody>
  </table>
  <form id="export">
    Auswahl
    <label>als <input type="text" value="export" name="filename"></label>
    <label><input type="radio" name="filetype" value="geojson" checked>.geojson</label>
    <label><input type="radio" name="filetype" value="xml">.xml-Tabelle</label>
    <label><input type="radio" name="filetype" value="couchdb">CouchDB</label>
    <span class="nowrap">
      <input type="button" value="speichern" name="download">
      <input type="button" value="URL erzeugen" name="get-url"></span>
    <input type="text" name="url" style="display:none">
    <span name="columns" class="nowrap">
      <label><input type="radio" name="select-fields" checked>alle</label>
      <label><input type="radio" name="select-fields" value="from-table">ausgewählte Spalten</label></span>
    <span name="columns" class="nowrap">
      <label><input type="checkbox" name="include-revision" checked>_id, _rev</label>
      <label><input type="checkbox" name="include-geojson-id" checked>Geometrie-Schlüssel</label></span>
    <input type="button" value="replizieren" name="replicate" style="display:none">
    <a name="replicant" target="_blank" style="display:none">zur Datenbank wechseln</a><br>
    <a name="replicate-status" style="display:none"></a>
  </form>
  </body>
</html>
